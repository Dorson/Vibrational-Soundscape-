<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Binaural Beats & Sound Therapy for Focus, Meditation & Sleep</title>
 <meta name="theme-color" content="#d4a017">
 <link rel="manifest" href="manifest.json" crossOrigin="use-credentials">
 <style>
 :root {
 --bg: #1a120b;
 --bg-secondary: #2a1e14;
 --accent: #d4a017;
 --accent-secondary: #8b4513;
 --text: #f5f5f5;
 --muted: #a0a0a0;
 --checkmark-color: #4CAF50;
 }

 /* --- Base & Resets --- */
 html {
 font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
 font-size: clamp(1rem, 0.8rem + 0.8vw, 1.5rem); /* Wider, more dynamic scaling */
 height: 100%;
 background: var(--bg);
 color: var(--text);
 }
 body {
 margin: 0;
 display: flex;
 flex-direction: column;
 align-items: center;
 padding: 0.5rem 1rem 9rem 1rem;
 overflow-x: visible;
 min-height: 100vh;
 box-sizing: border-box;
 }
 *, *::before, *::after {
 box-sizing: inherit;
 }

 /* --- Layout --- */
 .main-container {
 width: 100%;
 max-width: 95%; /* Wider on small screens */
 position: relative;
 margin: 0.1rem auto 15rem auto; /* Centered */
 z-index: 10;
 display: flex;
 flex-direction: column;
 min-height: calc(100vh - 2rem); /* Accommodate body padding */
 }

 /* --- Header --- */
 .header {
 display: flex;
 align-items: center;
 justify-content: space-between;
 padding: 1rem 0;
 }
 .header h1 {
 font-size: 1.875rem;
 font-weight: 700;
 color: var(--accent);
 margin: 0;
 }
 .header p {
 font-size: 0.875rem;
 color: var(--muted);
 margin: 0;
 }

 /* --- Generic Panel/Card --- */
 .panel {
 background-color: rgba(39, 39, 42, 0.4);
 backdrop-filter: blur(0.75rem);
 border-radius: 1rem;
 padding: 1.5rem;
 margin-bottom: 2rem;
 box-shadow: 0 0.625rem 0.9375rem -0.1875rem rgb(0 0 0 / 0.1), 0 0.25rem 0.375rem -0.25rem rgb(0 0 0 / 0.1);
 }

 /* --- Stage Info Panel --- */
 .stage-info-panel {
 display: flex;
 flex-direction: column;
 align-items: center;
 width: 100%;
 text-align: center;
 }
 #stageName {
 font-size: 1.25rem;
 font-weight: 600;
 color: var(--accent);
 }
 #stageSub {
 font-size: 0.875rem;
 color: var(--muted);
 margin-top: 0.25rem;
 }
 .progress-bar-container {
 width: 100%;
 height: 0.375rem;
 background-color: var(--bg-secondary);
 border-radius: 9999px;
 margin-top: 1rem;
 overflow: hidden;
 }
 #progressBar {
 height: 100%;
 width: 0;
 background-color: var(--accent);
 transition: width 500ms ease-in-out;
 }

 /* --- Settings Panel --- */
 .settings-panel h2 {
 font-size: 1.25rem;
 font-weight: 600;
 margin-top: 0;
 margin-bottom: 1rem;
 }
 .settings-group {
 margin-bottom: 1.5rem;
 }
 .settings-group label {
 display: block;
 font-size: 1rem;
 font-weight: 500;
 margin-bottom: 0.5rem;
 }
 #presetSelector {
 width: 100%;
 padding: 0.5rem;
 border-radius: 0.5rem;
 font-size: 1.3rem;
 font-weight: 500;
 background: var(--bg-secondary);
 background: linear-gradient(90deg,rgba(156, 148, 42, 0.2) 0%, rgba(44, 74, 17, 0.2) 50%, rgba(64, 57, 8, 0.2) 100%);
 color: var(--text);
 border: 0.1rem solid orange;
 border-bottom: 0.2rem double gold;
 }
 #presetSelector:focus {
 outline: none;
 background: var(--bg-secondary);
 box-shadow: 0 0 0 0.125rem var(--accent);
 }
 .slider-group {
 margin-bottom: 1rem;
 }
 .slider-label {
 display: flex;
 align-items: baseline;
 margin-bottom: 0.5rem;
 font-size: 1.5rem;
 gap: 0.75rem;
 }

/* Slider Value Indicator */
 .slider-label span:first-child {
 font-weight: 600;
 color: var(--accent);
 font-size: 1.25rem; /* Slightly smaller to prevent wrapping */
 min-width: 4.5rem; /* More flexible for small screens */
 text-align: center;
 }
 .toggle-group > * + * {
 margin-top: 0.5rem;
 }
 .toggle-button {
 width: 100%;
 text-align: left;
 display: flex;
 justify-content: flex-start;
 align-items: center;
 padding: 0.8rem;
 border-radius: 0.75rem;
 transition: background-color 150ms ease-in-out;
 background: none;
 border: none;
 color: var(--text);
 cursor: pointer;
 font-size: 1.2rem;
 font-weight: 600;
 letter-spacing: 0.15rem;
 gap: 0.8rem;
 }
 .toggle-button:hover {
 background-color: rgba(255, 255, 255, 0.1);
 }
 .toggle-button:focus-visible {
 outline: none;
 box-shadow: 0 0 0 0.125rem var(--bg-secondary), 0 0 0 0.25rem var(--accent);
 }
 .toggle-button[aria-checked="false"] .checkmark-container {
 border-width: 0.1875rem;
 }
 .checkmark-container {
 width: 2rem;
 height: 2rem;
 border-radius: 1rem;
 border: 0.25rem solid var(--checkmark-color);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: all 200ms;
 }
 .checkmark {
 width: 1.5rem;
 height: 1.5rem;
 border-radius: 1rem;
 transition: all 200ms;
 }
 .bg-accent { background-color: var(--accent); }
 .bg-black { background-color: black; }

 /* --- Info Section --- */
 .info-cards {
 margin-bottom: 1rem; /* Adjusted margin */
 }
 .info-cards > .panel + .panel {
 margin-top: 1rem;
 }
 .info-panel h3 {
 font-size: 1.125rem;
 font-weight: 600;
 color: var(--accent);
 margin-top: 0;
 margin-bottom: 0.5rem;
 }
 .info-panel p, .info-panel ol, .info-panel ul {
 font-size: 0.875rem;
 line-height: 1.625;
 margin: 0;
 }
 .info-panel ol, .info-panel ul {
 padding-left: 1.25rem;
 margin-top: 0.5rem;
 }
 .info-panel ol > li + li, .info-panel ul > li + li {
 margin-top: 0.25rem;
 }

 /* --- About Section --- */
 .about-section hr {
 border-color: var(--bg-secondary);
 margin: 1rem 0;
 border-style: solid;
 border-top-width: 0.0625rem;
 }
 .about-section .content {
 margin-top: 2rem;
 }
 .about-section h2 {
 font-size: 1.5rem;
 font-weight: 700;
 color: var(--accent);
 margin-top: 0;
 margin-bottom: 1rem;
 }
 .about-section h3 {
 font-size: 1.25rem;
 font-weight: 600;
 margin-top: 0;
 margin-bottom: 0.5rem;
 }
 .about-section p, .about-section ul {
 font-size: 0.875rem;
 line-height: 1.625;
 color: var(--muted);
 margin-top: 0;
 margin-bottom: 1rem;
 }
 .about-section ul {
 padding-left: 1.25rem;
 }
 .about-section ul.no-bullets {
 list-style-type: none;
 padding-left: 0;
 }
 .about-section ul > li + li {
 margin-top: 0.25rem;
 }
 .about-section ul.no-bullets > li + li {
 margin-top: 1rem;
 }
 .about-section strong {
 color: var(--accent);
 font-weight: 600;
 }

 /* --- Sticky Footer Controls --- */
 .footer-controls {
 position: fixed;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: rgba(26, 18, 11, 0.4);
 backdrop-filter: blur(0.5625rem);
 z-index: 50;
 padding: 0.1rem;
 box-shadow: 0 -0.625rem 1.5625rem -0.3125rem rgb(100 100 50 / 0.25);
 }
 .footer-controls-inner {
 display: flex;
 gap: 1rem;
 width: 100%;
 max-width: 90%;
 margin: 0 auto;
 }
 .control-button {
 flex: 1 1 0%;
 display: flex;
 align-items: center;
 justify-content: center;
 padding: 0.5rem 1rem;
 border-radius: 1rem;
 font-weight: 800;
 font-size: clamp(1.5rem, 1.2rem + 1vw, 2rem); /* Fluid font size */
 box-shadow: 0 0.625rem 0.9375rem -0.1875rem rgb(0 0 0 / 0.1), 0 0.25rem 0.375rem -0.25rem rgb(0 0 0 / 0.1);
 transition: transform 150ms, background-color 150ms;
 border: none;
 cursor: pointer;
 }
 .control-button:active {
 transform: scale(0.95);
 }
 #playPauseBtn {
 gap: 1rem;
 background-color: var(--accent-secondary);
 color: white;
 }
 #playPauseBtn:hover {
 background-color: hsl(27, 69%, 35%);
 }
 #nextStageBtn {
 gap: 0.5rem;
 background-color: transparent;
 border: 0.125rem solid var(--accent);
 color: var(--accent);
 }
 #nextStageBtn:hover {
 background-color: rgba(255, 255, 255, 0.1);
 }
 
 .button-row {
 display: flex;
 gap: 1rem;
 align-items: center;
 }
 .settings-button {
 padding: 0.8rem 1.2rem;
 border-radius: 0.75rem;
 font-weight: 600;
 font-size: 1.1rem;
 border: none;
 cursor: pointer;
 transition: background-color 150ms, transform 150ms, border-color 150ms;
 text-decoration: none;
 display: inline-block;
 text-align: center;
 }
 .settings-button:active {
 transform: scale(0.97);
 }
 .save-audio-button {
 background-color: var(--accent);
 color: var(--bg);
 }
 .save-audio-button:hover {
 background-color: hsl(44, 78%, 60%);
 }
 .save-audio-button:disabled {
 background-color: var(--bg-secondary);
 color: var(--muted);
 cursor: not-allowed;
 transform: none;
 }
 .install-app-button {
 background-color: transparent;
 border: 0.125rem solid var(--accent-secondary);
 color: var(--accent);
 padding: calc(0.8rem - 0.125rem) calc(1.2rem - 0.125rem);
 }
 .install-app-button:hover {
 background-color: var(--bg-secondary);
 border-color: var(--accent);
 }
 
 /* --- Media Queries --- */
 @media (min-width: 40rem) { /* 640px */
 body {
 padding: 1.5rem;
 }
 .main-container {
 min-height: calc(100vh - 3rem);
 max-width: 80%; /* Constrain width on tablets and desktops */
 }
 .footer-controls {
 padding: 1rem;
 }
 }
 
  @media (min-width: 64rem) { /* 1024px */
   .main-container {
     max-width: 60rem; /* Add a max-width for very large screens */
   }
 }
 
 .play-icon {
 width: 0;
 height: 0;
 border-top: 1.25rem solid transparent;
 border-bottom: 1.25rem solid transparent;
 border-left: 2.125rem solid white;
 }
 .pause-icon {
 width: 2.125rem;
 height: 2.5rem;
 border-left: 0.625rem solid white;
 border-right: 0.625rem solid white;
 }

 /* --- Slider Styles --- */
 input[type="range"] {
 -webkit-appearance: none; appearance: none;
 background: transparent; width: 100%; cursor: pointer;
 }
 /* Track */
 input[type="range"]::-webkit-slider-runnable-track {
 background: var(--bg-secondary);
 height: 0.7rem;
 border-radius: 0.5rem;
 background-image: radial-gradient(rgba(100, 100, 50, 0.33) 0.15rem, transparent 0);
 background-repeat: repeat;
 background-size: 0.7rem 0.7rem;
 background-position: left;
 }
 input[type="range"]::-moz-range-track {
 background: var(--bg-secondary);
 height: 0.7rem;
 border-radius: 0.5rem;
 background-image: radial-gradient(rgba(100, 100, 50, 0.33) 0.15rem, transparent 0);
 background-repeat: repeat;
 background-size: 0.7rem 0.7rem;
 background-position: left;
 }
 /* Thumb */
 input[type="range"]::-webkit-slider-thumb {
 -webkit-appearance: none;
 appearance: none;
 height: 2rem;
 width: 1rem;
 background-color: var(--accent);
 border-radius: 10%;
 border: 0;
 border-bottom: 0.15rem double green;
 margin-top: -0.65rem; /* Vertically center thumb on track */
 }
 input[type="range"]::-moz-range-thumb {
 height: 2rem;
 width: 1rem;
 background-color: var(--accent);
 border-radius: 10%;
 border: 0;
 border-bottom: 0.15rem double green;
 }
 
 /* --- CSS Gradient Blob Animation --- */
 #gradientBlobsContainer {
 position: fixed; top: 0; left: 0; width: 100%; height: 100%;
 z-index: 0; pointer-events: none; filter: blur(5rem); opacity: 0.8;
 }
 .blob {
 position: absolute;
 background-image: radial-gradient(circle at center, rgba(212, 160, 23, 0.7), rgba(42, 30, 20, 0.2));
 border-radius: 50%;
 animation: float-blob 40s linear infinite alternate;
 }
 .blob:nth-child(1) { width: 15.625rem; height: 15.625rem; top: 10%; left: 20%; animation-delay: 2s; }
 .blob:nth-child(2) { width: 18.75rem; height: 18.75rem; top: 40%; left: 70%; animation-delay: 10s; }
 .blob:nth-child(3) { width: 12.5rem; height: 12.5rem; top: 60%; left: 15%; animation-delay: 20s; }
 .blob:nth-child(4) { width: 21.875rem; height: 21.875rem; top: 80%; left: 50%; animation-delay: 35s; }
 .blob:nth-child(5) { width: 11.25rem; height: 11.25rem; top: 5%; left: 80%; animation-delay: 15s; }
 @keyframes float-blob {
 0% { transform: translate(0, 0) scale(1.0); }
 25% { transform: translate(-10vw, -15vh) scale(1.1); }
 50% { transform: translate(15vw, 5vh) scale(0.9); }
 75% { transform: translate(-5vw, 10vh) scale(1.2); }
 100% { transform: translate(0, 0) scale(1.0); }
 }

 #install-instructions ul svg {
     width: 1em;
     height: 1em;
 }
 </style>
</head>
<body>
 
 <div id="gradientBlobsContainer">
 <div class="blob"></div><div class="blob"></div><div class="blob"></div><div class="blob"></div><div class="blob"></div>
 </div>

 <div class="main-container">
 <header class="header">
 <div>
 <h1>Binaural Beats & Sound Therapy</h1>
 <p>Headphones recommended • Low volume</p>
 </div>
 </header>

 <main>
 <div class="panel stage-info-panel">
 <div id="stageInfo" class="stage-info" aria-live="polite">
 <div id="stageName">Idle • Ready</div>
 <div id="stageSub">Manual step or Auto-play available</div>
 <div class="progress-bar-container">
 <div id="progressBar"></div>
 </div>
 </div>
 </div>

 <div class="panel settings-panel">
 <div class="settings-group">
 <div class="button-row">
 <button id="saveAudioBtn" class="settings-button save-audio-button">Save Audio</button>
 <a href="#install-instructions" id="installAppBtn" class="settings-button install-app-button">Install App</a>
 </div>
 </div>
 <div class="settings-group">
 <h2>Presets</h2>
 <label for="presetSelector">Select a Preset</label>
 <select id="presetSelector">
 <option value="none">Custom</option>
 <option value="focus">Focus</option>
 <option value="meditation">Meditation</option>
 <option value="relaxation">Relaxation</option>
 <option value="deep_sleep">Deep Sleep</option>
 <option value="energetic">Energetic</option>
 <option value="bliss">Bliss</option>
 </select>
 </div>

 <h2>Settings</h2>
 <div class="slider-group">
 <div class="slider-label">
 <span id="lenLabel">10</span>
 <span>Session Length (minutes)</span>
 </div>
 <input id="lengthSlider" type="range" min="3" max="60" value="10">
 </div>

 <div class="slider-group">
 <div class="slider-label">
 <span id="intLabel">0.6</span>
 <span>Effects Intensity (volume)</span>
 </div>
 <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.6">
 </div>
 
 <div class="toggle-group">
 <h3> SoundScape Layer Effects </h3>
 <button id="isoOption" role="switch" aria-checked="true" class="toggle-button">
 <div class="checkmark-container" id="isoChkContainer">
 <div id="isoChk" class="checkmark"></div>
 </div>
 <span>Isochronic gating</span>
 </button>
 <button id="noiseOption" role="switch" aria-checked="true" class="toggle-button">
 <div class="checkmark-container" id="noiseChkContainer">
 <div id="noiseChk" class="checkmark"></div>
 </div>
 <span>Pink noise</span>
 </button>
 <button id="windOption" role="switch" aria-checked="true" class="toggle-button">
 <div class="checkmark-container" id="windChkContainer">
 <div id="windChk" class="checkmark"></div>
 </div>
 <span>3D Wind effect</span>
 </button>
 <button id="drumOption" role="switch" aria-checked="true" class="toggle-button">
 <div class="checkmark-container" id="drumChkContainer">
 <div id="drumChk" class="checkmark"></div>
 </div>
 <span>Shamanic drum</span>
 </button>
 <button id="bowlOption" role="switch" aria-checked="true" class="toggle-button">
 <div class="checkmark-container" id="bowlChkContainer">
 <div id="bowlChk" class="checkmark"></div>
 </div>
 <span>Distant Singing Bowl</span>
 </button>
 <button id="deepSleepOption" role="switch" aria-checked="false" class="toggle-button">
 <div class="checkmark-container" id="deepSleepChkContainer">
 <div id="deepSleepChk" class="checkmark"></div>
 </div>
 <span>3D Sleep Waves</span>
 </button>
 </div>
 </div>
 
 <div class="info-cards">
 <div class="panel info-panel">
 <h3>How to use</h3>
 <p>Step through stages manually or use auto-play. Each stage gradually changes sound parameters for a smooth experience.</p>
 </div>
 <div class="panel info-panel">
 <h3>Stages</h3>
 <ol>
 <li><strong>Grounding</strong> — deep hum, slow breath</li>
 <li><strong>Energetic</strong> — nerve-tingle textures</li>
 <li><strong>Focus</strong> — clarity, midband polish</li>
 <li><strong>Intuitive</strong> — alpha/theta focus</li>
 <li><strong>Bliss</strong> — harmonic bloom</li>
 </ol>
 </div>
 <div class="panel info-panel">
 <h3>Safety</h3>
 <p>Start at low volume. Stop if you feel discomfort. Not for use while driving or operating machinery.</p>
 </div>
 </div>

 <section id="install-instructions" class="panel info-panel">
 <h3>Install as an App</h3>
 <p>For quick offline access, you can install this soundscape generator on your device. This adds an icon to your home screen or desktop, just like a native app.</p>
 <ul style="padding-left: 1.25rem; margin-top: 0.5rem; list-style-type: disc;">
 <li><strong>Desktop (Chrome, Edge):</strong> Click the three-dot menu icon ( <svg style="display:inline; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg> ) in the top-right corner, open the 'Save and Share' submenu, and then click 'Install...'. On some versions, you might see an install icon directly in the address bar.</li>
 <li><strong>iPhone / iPad (Safari):</strong> Tap the 'Share' icon ( <svg style="display:inline; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg> ), then scroll down and select 'Add to Home Screen'.</li>
 <li><strong>Android (Chrome):</strong> Tap the three-dot menu icon ( <svg style="display:inline; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></svg> ), then select 'Install app' or 'Add to Home screen'.</li>
 </ul>
 </section>

 <section class="about-section">
 <hr>
 <div class="content">
 <h2>About This Soundscape</h2>
 
 <h3>What are Binaural Beats and Sound Therapy?</h3>
 <p>
 This app is an immersive <strong>binaural beat</strong> soundscape designed to guide your mind into various states of consciousness. By playing two slightly different frequencies in each ear, it creates an auditory illusion that the brain perceives as a third tone—the <strong>binaural beat</strong>. This process, known as <strong>brainwave entrainment</strong>, can influence your mental state to help you relax, focus, or even fall asleep.
 </p>

 <h3>The Stages of Sound and Their Effects</h3>
 <p>
 Each stage of this soundscape is carefully engineered to produce a different mental effect, building on the previous one. The combination of subtle sound effects and binaural beats work together to gently shift your focus and awareness.
 </p>
 <ul class="no-bullets">
 <li>
 <strong>Grounding:</strong> A deep, resonant hum combined with a slow beat helps quiet your mind and anchor your awareness in your body. It is ideal for starting a session of <strong>mindfulness</strong> or <strong>meditation</strong>.
 </li>
 <li>
 <strong>Energetic:</strong> A slightly higher frequency hum and pulsing beat create a stimulating sensation, designed to promote a sense of vitality and awaken your nervous system.
 </li>
 <li>
 <strong>Focus:</strong> The sound focuses on mid-range frequencies and beats that are associated with improved <strong>concentration</strong> and mental clarity, making it a great tool for <strong>focus</strong> during work or study.
 </li>
 <li>
 <strong>Intuitive:</strong> The soundscape shifts to the alpha and theta brainwave range, which are linked to <strong>deep relaxation</strong>, <strong>creativity</strong> and accessing the subconscious mind. This is the stage for introspection and meditative states.
 </li>
 <li>
 <strong>Bliss:</strong> A finale of complex, harmonic tones that create a full sound. This stage aims to evoke a sense of peacefulness, harmony, and overall <strong>well-being</strong>.
 </li>
 </ul>

 <h3>Use Cases & Benefits</h3>
 <p>This soundscape is a versatile tool for personal mental wellness. It can be used for:</p>
 <ul class="bullets">
 <li><strong>Meditation</strong> and <strong>mindfulness</strong> practices</li>
 <li><strong>Relaxation</strong> and <strong>stress reduction</strong></li>
 <li>Enhancing <strong>focus</strong> and <strong>concentration</strong> during work or study sessions</li>
 <li>Boosting <strong>creativity</strong> and <strong>intuition</strong></li>
 <li>Preparing for <strong>sleep</strong> or deep rest</li>
 </ul>
 <p>
 The effectiveness of these sounds can vary by individual. Experiment with different session lengths and intensity levels to find what works best for you.
 </p>
 </div>
 </section>
 </main>
 </div>
 
 <footer class="footer-controls">
 <div class="footer-controls-inner">
 <button id="playPauseBtn" class="control-button">
 <div id="playIcon" class="play-icon"></div>
 <span id="playPauseLabel">Play</span>
 </button>
 <button id="nextStageBtn" class="control-button">
 Next Stage
 </button>
 </div>
 </footer>

<script>
 const app = {
 PRESETS: {
 none: { stages: [{name:'Grounding', base:55, beat:2.5, padCut:900, iso:2.0, noise:0.08}, {name:'Energetic', base:95, beat:6.5, padCut:1200, iso:4.5, noise:0.095}, {name:'Focus', base:140, beat:10.0, padCut:1800, iso:3.0, noise:0.06}, {name:'Intuitive', base:160, beat:7.5, padCut:2500, iso:2.0, noise:0.045}, {name:'Bliss', base:240, beat:40.0, padCut:4800, iso:0.8, noise:0.02}], toggles: { iso: true, noise: true, wind: true, drum: true, bowl: true, deepSleep: false }, intensity: 0.6 },
 focus: { stages: [{name:'Beta Wave', base:140, beat:18.0, padCut:1500, iso:10.0, noise:0.05}, {name:'Gamma Wave', base:200, beat:40.0, padCut:2500, iso:25.0, noise:0.0}], toggles: { iso: true, noise: true, wind: false, drum: false, bowl: false, deepSleep: false }, intensity: 0.8 },
 meditation: { stages: [{name:'Alpha Wave', base:90, beat:10.0, padCut:800, iso:5.0, noise:0.04}, {name:'Theta Wave', base:60, beat:6.0, padCut:500, iso:3.0, noise:0.02}, {name:'Deep Theta', base:40, beat:4.0, padCut:300, iso:1.5, noise:0.01}], toggles: { iso: true, noise: true, wind: false, drum: true, bowl: true, deepSleep: false }, intensity: 0.5 },
 relaxation: { stages: [{name:'Relax', base:120, beat:8.0, padCut:1000, iso:4.0, noise:0.03}, {name:'Deep Calm', base:80, beat:6.0, padCut:700, iso:2.0, noise:0.01}], toggles: { iso: true, noise: true, wind: true, drum: false, bowl: true, deepSleep: false }, intensity: 0.4 },
 deep_sleep: { stages: [{name:'Delta Wave', base:100, beat:2.0, padCut:250, iso:0.8, noise:0.05}, {name:'Deep Delta', base:100, beat:0.5, padCut:150, iso:0.5, noise:0.08}, {name:'3D Delta', base:110, beat:1.5, padCut:100, iso:0.3, noise:0.0, deepSleepOn: true}], toggles: { iso: true, noise: true, wind: false, drum: false, bowl: false, deepSleep: true }, intensity: 0.3 },
 energetic: { stages: [{name:'Energetic', base:95, beat:6.5, padCut:1200, iso:4.5, noise:0.095}], toggles: { iso: true, noise: true, wind: true, drum: true, bowl: false, deepSleep: false }, intensity: 0.6 },
 bliss: { stages: [{name:'Bliss', base:240, beat:40.0, padCut:4800, iso:0.8, noise:0.02}], toggles: { iso: true, noise: true, wind: true, drum: false, bowl: true, deepSleep: false }, intensity: 0.7 }
 },

 config: {
 MASTER_GAIN_MULTIPLIER: 0.45,
 PAD_GAIN_MULTIPLIER: 0.6,
 DEEP_SLEEP_GAIN_MULTIPLIER: 0.15,
 FADE_DURATION_S: 3,
 PAUSE_FADE_DURATION_S: 1,
 RESUME_FADE_DURATION_S: 2,
 STAGE_CHANGE_RAMP_S: 4,
 MIN_GAIN: 0.0001,
 AUTOPLAY_TICK_MS: 250,
 },
 
 toggleConfigs: [
 { stateKey: 'isIsoEnabled', optionId: 'isoOption', chkId: 'isoChk', nodeKey: 'iso' },
 { stateKey: 'isNoiseEnabled', optionId: 'noiseOption', chkId: 'noiseChk', nodeKey: 'noise' },
 { stateKey: 'isWindEnabled', optionId: 'windOption', chkId: 'windChk', nodeKey: 'wind' },
 { stateKey: 'isDrumEnabled', optionId: 'drumOption', chkId: 'drumChk', nodeKey: 'drum' },
 { stateKey: 'isBowlEnabled', optionId: 'bowlOption', chkId: 'bowlChk', nodeKey: 'bowl' },
 { stateKey: 'isDeepSleepEnabled', optionId: 'deepSleepOption', chkId: 'deepSleepChk', nodeKey: 'deepSleep' },
 ],

 state: {
 STAGES: [],
 currentStage: -1,
 autoplayInterval: null,
 sessionElapsedTime: 0,
 lastTickTime: 0,
 isIsoEnabled: true,
 isNoiseEnabled: true,
 isWindEnabled: true,
 isDrumEnabled: true,
 isBowlEnabled: true,
 isDeepSleepEnabled: false,
 },

 audio: {
 ctx: null,
 masterGain: null,
 effectsGain: null,
 nodes: {},
 },

 ui: {},

 // --- Core Methods ---
 init() {
 // 1. Set initial state
 this.state.STAGES = this.PRESETS.none.stages;

 // 2. Cache UI elements
 this.ui = {
 playPauseBtn: document.getElementById('playPauseBtn'),
 playIcon: document.getElementById('playIcon'),
 playPauseLabel: document.getElementById('playPauseLabel'),
 nextStageBtn: document.getElementById('nextStageBtn'),
 saveAudioBtn: document.getElementById('saveAudioBtn'),
 lengthSlider: document.getElementById('lengthSlider'),
 intensitySlider: document.getElementById('intensity'),
 lenLabel: document.getElementById('lenLabel'),
 intLabel: document.getElementById('intLabel'),
 stageName: document.getElementById('stageName'),
 stageSub: document.getElementById('stageSub'),
 progressBar: document.getElementById('progressBar'),
 presetSelector: document.getElementById('presetSelector'),
 };
 
 this.toggleConfigs.forEach(config => {
 this.ui[config.optionId] = document.getElementById(config.optionId);
 this.ui[config.chkId] = document.getElementById(config.chkId);
 });

 // 3. Bind event listeners
 this.ui.playPauseBtn.addEventListener('click', this.handlePlayPause.bind(this));
 this.ui.nextStageBtn.addEventListener('click', this.goToNextStage.bind(this));
 this.ui.saveAudioBtn.addEventListener('click', this.handleSaveAudio.bind(this));
 this.ui.lengthSlider.addEventListener('input', e => this.ui.lenLabel.textContent = e.target.value);
 this.ui.intensitySlider.addEventListener('input', this.handleIntensityChange.bind(this));
 this.ui.presetSelector.addEventListener('change', this.handlePresetChange.bind(this));
 
 this.toggleConfigs.forEach(config => {
 this.ui[config.optionId].addEventListener('click', () => {
 this.handleToggle(config.stateKey, this.ui[config.optionId], this.ui[config.chkId], config.nodeKey);
 });
 });
 
 // 4. Initial UI sync
 this.initUIState();
 },
 
 // --- Audio Engine ---
 createAudioContext() {
 if (this.audio.ctx) {
 this.audio.ctx.close();
 }
 this.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
 return this.audio.ctx;
 },

 // Generates a simple algorithmic reverb impulse response from decaying white noise.
 createReverb(ctx, duration = 3, decay = 2.0) {
 const rate = ctx.sampleRate, len = Math.floor(duration * rate), buf = ctx.createBuffer(2, len, rate);
 for(let ch = 0; ch < 2; ch++) {
 const d = buf.getChannelData(ch);
 for(let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / rate) / duration, decay);
 }
 const conv = ctx.createConvolver();
 conv.buffer = buf;
 return conv;
 },
 
 createCarrierPair(ctx) {
 const left = ctx.createOscillator(), right = ctx.createOscillator();
 left.type = right.type = 'sine';
 left.frequency.value = right.frequency.value = 60;
 left.start(); right.start();
 
 const lfo = ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.06;
 const lfoG = ctx.createGain(); lfoG.gain.value = 1.6;
 lfo.connect(lfoG); lfoG.connect(left.frequency); lfoG.connect(right.frequency); lfo.start();

 const panL = ctx.createStereoPanner(); panL.pan.value = -0.6;
 const panR = ctx.createStereoPanner(); panR.pan.value = 0.6;

 const gL = ctx.createGain(), gR = ctx.createGain(); gL.gain.value = gR.gain.value = 0.45;

 left.connect(panL); right.connect(panR); panL.connect(gL); panR.connect(gR);

 return {
 leftOsc: left, rightOsc: right, outputLeft: gL, outputRight: gR,
 setBinaural: (base, beat, when = ctx.currentTime, ramp = this.config.STAGE_CHANGE_RAMP_S) => {
 left.frequency.linearRampToValueAtTime(Math.max(8, base - beat / 2), when + ramp);
 right.frequency.linearRampToValueAtTime(Math.max(8, base + beat / 2), when + ramp);
 }
 };
 },

 createPadLayer(ctx) {
 const master = ctx.createGain(); master.gain.value = 0.0;
 const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1200; filter.Q.value = 0.7;
 master.connect(filter);

 const out = ctx.createGain(); out.gain.value = this.config.PAD_GAIN_MULTIPLIER; filter.connect(out);
 const base = 110;
 for(let i = 0; i < 3; i++) {
 const osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = base * (1 + (i-1)*0.02);
 const lfo = ctx.createOscillator(); lfo.frequency.value = 0.02 + Math.random()*0.04;
 const lg = ctx.createGain(); lg.gain.value = 0.5 + Math.random()*0.6;
 lfo.connect(lg); lg.connect(osc.frequency); lfo.start(); osc.start(); osc.connect(master);
 }

 const ampLFO = ctx.createOscillator(); ampLFO.frequency.value = 0.03;
 const ampG = ctx.createGain(); ampG.gain.value = 0.25;
 ampLFO.connect(ampG); ampG.connect(master.gain); ampLFO.start();
 return { output: out, filter, setFilter: (cut, when=ctx.currentTime, ramp=this.config.STAGE_CHANGE_RAMP_S) => filter.frequency.linearRampToValueAtTime(cut, when + ramp) };
 },

 // Creates pink noise using the Voss-McCartney algorithm to filter white noise.
 createPinkNoise(ctx) {
 const buffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate), data = buffer.getChannelData(0);
 let b0 = 0, b1 = 0;
 for(let i = 0; i < data.length; i++) {
 const white = Math.random() * 2 - 1;
 b0 = 0.99765 * b0 + white * 0.0990460; b1 = 0.96300 * b1 + white * 0.2965164;
 data[i] = (b0 + b1 + white * 0.1848) * 0.25;
 }
 const src = ctx.createBufferSource(); src.buffer = buffer; src.loop = true;
 const g = ctx.createGain(); src.connect(g); src.start(); return g;
 },

 createIsoLayer(ctx) {
 const osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 80;
 const outG = ctx.createGain();
 const gate = ctx.createOscillator(); gate.type = 'sine'; gate.frequency.value = 4.0;
 const gateG = ctx.createGain(); gateG.gain.value = 0.6;
 gate.connect(gateG); gateG.connect(outG.gain);
 osc.connect(outG); osc.start(); gate.start();
 return { output: outG, gainNode: outG, gate, setRate: (hz, when=ctx.currentTime, ramp=2) => gate.frequency.linearRampToValueAtTime(hz, when + ramp) };
 },

 createWindSound(ctx) {
 const buffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate), output = buffer.getChannelData(0);
 for (let i = 0; i < output.length; i++) output[i] = Math.random() * 2 - 1;
 const source = ctx.createBufferSource(); source.buffer = buffer; source.loop = true;
 const filter = ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 400; filter.Q.value = 0.5;
 const gainLFO = ctx.createOscillator(); gainLFO.type = 'sine'; gainLFO.frequency.value = 0.08;
 const gainMod = ctx.createGain(); gainMod.gain.value = 0.3; gainLFO.connect(gainMod);
 const mainGain = ctx.createGain(); mainGain.gain.value = 0.15;
 const panner = ctx.createStereoPanner(); panner.pan.value = 0;
 const panLFO = ctx.createOscillator(); panLFO.type = 'sine'; panLFO.frequency.value = 0.05;
 const panMod = ctx.createGain(); panMod.gain.value = 0.8; panLFO.connect(panMod); panMod.connect(panner.pan);
 source.connect(filter); filter.connect(mainGain); gainMod.connect(mainGain.gain); mainGain.connect(panner);
 source.start(); gainLFO.start(); panLFO.start();
 return { output: panner, gainNode: mainGain };
 },

 createShamanicDrum(ctx) {
    const subOsc = ctx.createOscillator(); subOsc.type = 'sine'; subOsc.frequency.value = 35; subOsc.start();
    const tremoloLFO = ctx.createOscillator(); tremoloLFO.type = 'sine'; tremoloLFO.frequency.value = 1.5; tremoloLFO.start();
    
    const lfoDepth = ctx.createGain();
    lfoDepth.gain.value = 0.4; // Modulation depth must be <= base gain to avoid negative values
    
    const tremoloGain = ctx.createGain();
    tremoloGain.gain.value = 0.5; // Base gain, so final gain will be in [0.1, 0.9] range

    tremoloLFO.connect(lfoDepth);
    lfoDepth.connect(tremoloGain.gain); // The LFO signal is ADDED to the gain AudioParam's intrinsic value.

    const mainGain = ctx.createGain(); mainGain.gain.value = 0.15; // Increased base volume
    subOsc.connect(tremoloGain); tremoloGain.connect(mainGain);
    return { output: mainGain, gainNode: mainGain };
 },

 createSingingBowl(ctx) {
    const baseFreq = 90;
    const partials = [
        { freq: baseFreq * 1,    gain: 1.0 },
        { freq: baseFreq * 2.005, gain: 0.7 },
        { freq: baseFreq * 3.42,  gain: 0.55 },
        { freq: baseFreq * 4.0,   gain: 0.25 },
        { freq: baseFreq * 5.71,  gain: 0.35 }
    ];

    const mainGain = ctx.createGain();
    mainGain.gain.value = 0.35; // It's a background effect.

    const panner = ctx.createStereoPanner();
    mainGain.connect(panner);

    const panLFO = ctx.createOscillator();
    panLFO.type = 'sine';
    panLFO.frequency.value = 0.025; // Slow pan
    const panMod = ctx.createGain();
    panMod.gain.value = 0.9; // Wide pan
    panLFO.connect(panMod);
    panMod.connect(panner.pan);
    panLFO.start();

    const envelope = ctx.createGain();
    envelope.gain.value = 0.0;
    envelope.connect(mainGain);

    partials.forEach(p => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = p.freq;

        const vibLFO = ctx.createOscillator();
        vibLFO.type = 'sine';
        vibLFO.frequency.value = 2.5 + Math.random() * 2;
        const vibDepth = ctx.createGain();
        vibDepth.gain.value = p.freq * 0.004;
        vibLFO.connect(vibDepth);
        vibDepth.connect(osc.frequency);
        
        const partialGain = ctx.createGain();
        partialGain.gain.value = p.gain;
        
        osc.connect(partialGain);
        partialGain.connect(envelope);
        
        osc.start();
        vibLFO.start();
    });

    let intervalId = null;
    const trigger = (time) => {
        try {
            envelope.gain.cancelScheduledValues(time);
            envelope.gain.setValueAtTime(0, time);
            envelope.gain.linearRampToValueAtTime(1.0, time + 0.2); // Softer attack
            envelope.gain.exponentialRampToValueAtTime(this.config.MIN_GAIN, time + 45); // 45s decay
        } catch(e) {
            console.error("Error scheduling singing bowl:", e);
        }
    };
    
    const startLoop = () => {
        if (intervalId) clearInterval(intervalId);
        // Trigger immediately on play, then every 60s
        trigger(ctx.currentTime);
        intervalId = setInterval(() => {
            if (ctx.state === 'running') {
                trigger(ctx.currentTime);
            }
        }, 60000);
    };

    const stopLoop = () => {
        if (intervalId) clearInterval(intervalId);
        intervalId = null;
        envelope.gain.cancelScheduledValues(ctx.currentTime);
        envelope.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
    };

    return { output: panner, gainNode: mainGain, trigger, startLoop, stopLoop, envelope };
 },

 createDeepSleepBinaural(ctx) {
    const leftOsc = ctx.createOscillator(), rightOsc = ctx.createOscillator();
    leftOsc.type = rightOsc.type = 'sine'; leftOsc.start(); rightOsc.start();
    const volumeLFO = ctx.createOscillator(); volumeLFO.type = 'sine'; volumeLFO.frequency.value = 0.08; volumeLFO.start();
    const masterGain = ctx.createGain(); masterGain.gain.value = this.config.DEEP_SLEEP_GAIN_MULTIPLIER;
    const volGainMod = ctx.createGain(); volGainMod.gain.value = 0.1; // FIX: Reduced from 0.5 to prevent gain from going negative
    volumeLFO.connect(volGainMod); volGainMod.connect(masterGain.gain);
    const leftPanner = ctx.createStereoPanner(), rightPanner = ctx.createStereoPanner();
    const panLFO = ctx.createOscillator(); panLFO.type = 'sine'; panLFO.frequency.value = 0.015; panLFO.start();

    // FIX: Create a proper stereo sweep by inverting the pan LFO for the right channel
    const panMod = ctx.createGain();
    panMod.gain.value = 1.0; // Full sweep from -1 to 1
    const panInverter = ctx.createGain();
    panInverter.gain.value = -1;
    
    panLFO.connect(panMod);
    panMod.connect(leftPanner.pan);
    panMod.connect(panInverter);
    panInverter.connect(rightPanner.pan);
    
    leftOsc.connect(leftPanner); rightOsc.connect(rightPanner);
    const merger = ctx.createChannelMerger(2);
    leftPanner.connect(merger, 0, 0); rightPanner.connect(merger, 0, 1);
    merger.connect(masterGain);
    return { output: masterGain, gainNode: masterGain, leftOsc, rightOsc, setBinaural: (base, beat) => {
        leftOsc.frequency.setValueAtTime(base - beat / 2, ctx.currentTime);
        rightOsc.frequency.setValueAtTime(base + beat / 2, ctx.currentTime);
    }
    };
 },

 buildEngine() {
 const ctx = this.createAudioContext();
 this.audio.masterGain = ctx.createGain();
 this.audio.masterGain.gain.value = 0;
 this.audio.masterGain.connect(ctx.destination);
 
 this.audio.effectsGain = ctx.createGain();
 this.audio.effectsGain.gain.value = parseFloat(this.ui.intensitySlider.value);
 this.audio.effectsGain.connect(this.audio.masterGain);
 
 this.audio.nodes.reverb = this.createReverb(ctx);
 this.audio.nodes.reverb.connect(this.audio.masterGain);
 
 this.audio.nodes.carrier = this.createCarrierPair(ctx);
 this.audio.nodes.carrier.outputLeft.connect(this.audio.masterGain);
 this.audio.nodes.carrier.outputRight.connect(this.audio.masterGain);
 this.audio.nodes.carrier.outputLeft.connect(this.audio.nodes.reverb);
 this.audio.nodes.carrier.outputRight.connect(this.audio.nodes.reverb);
 
 this.audio.nodes.pad = this.createPadLayer(ctx);
 this.audio.nodes.pad.output.connect(this.audio.masterGain);
 this.audio.nodes.pad.output.connect(this.audio.nodes.reverb);

 const creators = {
 iso: this.createIsoLayer, noise: this.createPinkNoise, wind: this.createWindSound,
 drum: this.createShamanicDrum, bowl: this.createSingingBowl, deepSleep: this.createDeepSleepBinaural
 };
 
 this.toggleConfigs.forEach(({ stateKey, nodeKey }) => {
 const node = creators[nodeKey].call(this, ctx);
 const gainSwitch = ctx.createGain();
 gainSwitch.gain.value = this.state[stateKey] ? 1 : 0;
 
 const output = node.output || node;
 output.connect(gainSwitch);
 gainSwitch.connect(this.audio.effectsGain);
 if(nodeKey !== 'deepSleep') gainSwitch.connect(this.audio.nodes.reverb);

 this.audio.nodes[nodeKey] = { ...node, gainSwitch, source: output };
 });
 
 this.setStage(0, ctx.currentTime, 0.1);
 },

 setStage(idx, when, ramp = this.config.STAGE_CHANGE_RAMP_S) {
 if (!this.audio.ctx || !this.audio.nodes.carrier) return;
 this.state.currentStage = idx;
 const s = this.state.STAGES[idx];
 this.audio.nodes.carrier.setBinaural(s.base, s.beat, when, ramp);
 this.audio.nodes.pad.setFilter(s.padCut, when, ramp);
 if (this.audio.nodes.iso) this.audio.nodes.iso.setRate(s.iso, when, ramp);
 if (this.audio.nodes.noise) {
 this.audio.nodes.noise.source.gain.linearRampToValueAtTime(s.noise, when + ramp);
 }
 if (this.audio.nodes.deepSleep) {
 const targetGain = s.deepSleepOn ? this.config.DEEP_SLEEP_GAIN_MULTIPLIER : 0;
 this.audio.nodes.deepSleep.setBinaural(s.base, s.beat);
 this.audio.nodes.deepSleep.gainNode.gain.linearRampToValueAtTime(targetGain, when + ramp);
 }
 this.updateUIStage(idx);
 },

 startAuto() {
 this.stopAuto(); // Ensure no multiple timers are running
 this.state.lastTickTime = performance.now();
 this.state.autoplayInterval = setInterval(this.tickAutoplay.bind(this), this.config.AUTOPLAY_TICK_MS);
 },

 stopAuto() {
 clearInterval(this.state.autoplayInterval);
 this.state.autoplayInterval = null;
 },

 tickAutoplay() {
 const now = performance.now();
 const delta = (now - this.state.lastTickTime) / 1000;
 this.state.lastTickTime = now;
 this.state.sessionElapsedTime += delta;
 
 const totalDur = parseInt(this.ui.lengthSlider.value, 10) * 60;
 if (this.state.sessionElapsedTime >= totalDur) {
 this.stopEngine();
 return;
 }
 
 const stageDur = totalDur / this.state.STAGES.length;
 const expectedStage = Math.floor(this.state.sessionElapsedTime / stageDur);

 if (expectedStage < this.state.STAGES.length && expectedStage !== this.state.currentStage) {
 const ramp = Math.min(this.config.STAGE_CHANGE_RAMP_S, stageDur * 0.5);
 this.setStage(expectedStage, this.audio.ctx.currentTime, ramp);
 }
 },
 
 goToNextStage() {
    // If the audio context isn't created yet, this button acts as a play command.
    if (!this.audio.ctx) {
        this.handlePlayPause();
        return;
    }

    // If we're on the last stage, the next action is to stop the engine.
    if (this.state.currentStage >= this.state.STAGES.length - 1) {
        this.stopEngine();
        return;
    }

    // Otherwise, advance to the next stage.
    const nextStageIndex = this.state.currentStage + 1;
    
    // Sync the autoplay timer with the manual stage change.
    const totalDur = parseInt(this.ui.lengthSlider.value, 10) * 60;
    const stageDur = totalDur / this.state.STAGES.length;
    this.state.sessionElapsedTime = nextStageIndex * stageDur;
    
    // Also reset the tick timer to avoid a large jump in elapsed time on the next tick.
    if(this.state.autoplayInterval) {
        this.state.lastTickTime = performance.now();
    }
    
    this.setStage(nextStageIndex, this.audio.ctx.currentTime, this.config.STAGE_CHANGE_RAMP_S);

    // If the engine was paused ('suspended'), resume playback at the new stage.
    if (this.audio.ctx.state === 'suspended') {
        this.resumeEngine();
    }
 },

 stopEngine(callback) {
 if (!this.audio.ctx) { if(callback) callback(); return; }
 this.stopAuto();
 if (this.audio.nodes.bowl) this.audio.nodes.bowl.stopLoop();
 this.state.sessionElapsedTime = 0;

 try {
 this.audio.masterGain.gain.cancelScheduledValues(this.audio.ctx.currentTime);
 this.audio.masterGain.gain.linearRampToValueAtTime(this.config.MIN_GAIN, this.audio.ctx.currentTime + this.config.FADE_DURATION_S);
 } catch(e) { console.error("Error stopping gain ramp:", e); }

 setTimeout(() => {
 try { if (this.audio.ctx) this.audio.ctx.suspend(); }
 catch(e) { console.error("Error suspending audio context:", e); }
 this.state.currentStage = -1;
 this.updatePlayPauseButton('play');
 this.updateUIStage(-1);
 if (callback) callback();
 }, this.config.FADE_DURATION_S * 1000);
 },

 pauseEngine() {
 if (!this.audio.ctx || this.audio.ctx.state !== 'running') return;
 this.stopAuto();
 if (this.audio.nodes.bowl) this.audio.nodes.bowl.stopLoop();
 this.audio.masterGain.gain.cancelScheduledValues(this.audio.ctx.currentTime);
 this.audio.masterGain.gain.linearRampToValueAtTime(this.config.MIN_GAIN, this.audio.ctx.currentTime + this.config.PAUSE_FADE_DURATION_S);
 setTimeout(() => this.audio.ctx.suspend(), this.config.PAUSE_FADE_DURATION_S * 1000);
 },

 resumeEngine() {
 if (!this.audio.ctx || this.audio.ctx.state !== 'suspended') return;
 this.audio.ctx.resume();
 this.startAuto();
 if (this.audio.nodes.bowl) this.audio.nodes.bowl.startLoop();
 this.audio.masterGain.gain.cancelScheduledValues(this.audio.ctx.currentTime);
 const gainValue = this.config.MASTER_GAIN_MULTIPLIER;
 this.audio.masterGain.gain.linearRampToValueAtTime(gainValue, this.audio.ctx.currentTime + this.config.RESUME_FADE_DURATION_S);
 },
 
 // --- UI Update Functions ---
 updateUIStage(idx) {
 if (idx < 0) {
 this.ui.stageName.textContent = 'Idle • Ready';
 this.ui.stageSub.textContent = 'Manual step or Auto-play available';
 this.ui.progressBar.style.width = '0%';
 } else {
 this.ui.stageName.textContent = this.state.STAGES[idx].name;
 this.ui.stageSub.textContent = `Stage ${idx + 1} of ${this.state.STAGES.length}`;
 const progress = ((idx + 1) / this.state.STAGES.length) * 100;
 this.ui.progressBar.style.width = `${progress}%`;
 }
 },

 updatePlayPauseButton(state) {
 if (state === 'play') {
 this.ui.playIcon.className = 'play-icon';
 this.ui.playPauseLabel.textContent = 'Play';
 } else {
 this.ui.playIcon.className = 'pause-icon';
 this.ui.playPauseLabel.textContent = 'Pause';
 }
 },

 toggleCheckmark(button, checkmark, isEnabled) {
 button.setAttribute('aria-checked', isEnabled);
 checkmark.classList.toggle('bg-accent', isEnabled);
 checkmark.classList.toggle('bg-black', !isEnabled);
 },

 initUIState() {
 this.toggleConfigs.forEach(config => {
 this.toggleCheckmark(this.ui[config.optionId], this.ui[config.chkId], this.state[config.stateKey]);
 });
 },

 updatePresetUI(preset) {
 const toggles = preset.toggles;
 this.state.isIsoEnabled = !!toggles.iso;
 this.state.isNoiseEnabled = !!toggles.noise;
 this.state.isWindEnabled = !!toggles.wind;
 this.state.isDrumEnabled = !!toggles.drum;
 this.state.isBowlEnabled = !!toggles.bowl;
 this.state.isDeepSleepEnabled = !!toggles.deepSleep;

 this.initUIState();
 this.ui.intensitySlider.value = preset.intensity;
 this.ui.intLabel.textContent = preset.intensity;
 },
 
 // --- Event Handlers ---
 async handlePlayPause() {
 if (!this.audio.ctx) {
 this.buildEngine();
 await this.audio.ctx.resume();
 const gainValue = this.config.MASTER_GAIN_MULTIPLIER;
 this.audio.masterGain.gain.linearRampToValueAtTime(gainValue, this.audio.ctx.currentTime + this.config.RESUME_FADE_DURATION_S);
 this.updatePlayPauseButton('pause');
 this.state.sessionElapsedTime = 0;
 this.startAuto();
 if (this.audio.nodes.bowl) this.audio.nodes.bowl.startLoop();
 } else if (this.audio.ctx.state === 'running') {
 this.pauseEngine();
 this.updatePlayPauseButton('play');
 } else if (this.audio.ctx.state === 'suspended') {
 this.resumeEngine();
 this.updatePlayPauseButton('pause');
 }
 },

 handleIntensityChange(e) {
 this.ui.intLabel.textContent = e.target.value;
 if (this.audio.ctx && this.audio.effectsGain) {
 try {
 const intensity = parseFloat(e.target.value);
 this.audio.effectsGain.gain.linearRampToValueAtTime(intensity, this.audio.ctx.currentTime + 0.1);
 } catch (error) { console.error("Could not update gain:", error); }
 }
 },

 handleToggle(stateKey, button, checkmark, nodeKey) {
 this.state[stateKey] = !this.state[stateKey];
 this.toggleCheckmark(button, checkmark, this.state[stateKey]);
 if (this.audio.ctx && this.audio.nodes[nodeKey]) {
 const targetGain = this.state[stateKey] ? 1 : 0;
 this.audio.nodes[nodeKey].gainSwitch.gain.linearRampToValueAtTime(targetGain, this.audio.ctx.currentTime + 0.5);
 }
 },

 handlePresetChange(e) {
 const presetName = e.target.value;
 const preset = this.PRESETS[presetName];
 if (!preset) return;

 this.state.STAGES = preset.stages;
 this.updatePresetUI(preset);
 
 if (this.audio.ctx && this.audio.ctx.state !== 'closed') {
 this.stopEngine(() => {
 this.buildEngine();
 this.audio.ctx.resume().then(() => {
 const gainValue = this.config.MASTER_GAIN_MULTIPLIER;
 this.audio.masterGain.gain.linearRampToValueAtTime(gainValue, this.audio.ctx.currentTime + this.config.RESUME_FADE_DURATION_S);
 this.updatePlayPauseButton('pause');
 this.state.sessionElapsedTime = 0;
 this.startAuto();
 if (this.audio.nodes.bowl) this.audio.nodes.bowl.startLoop();
 });
 });
 }
 this.updateUIStage(-1);
 },
 
 async handleSaveAudio() {
 const btn = this.ui.saveAudioBtn;
 btn.disabled = true;
 
 let progressInterval = null;

 try {
 const durationSeconds = parseInt(this.ui.lengthSlider.value, 10) * 60;
 const sampleRate = 44100;

 // Heuristic for simulation: 50ms processing time per second of audio.
 // A 10min (600s) track is estimated to take 30s.
 const estimatedRenderTimeMs = durationSeconds * 50;
 const startTime = performance.now();
 
 progressInterval = setInterval(() => {
 const elapsedTime = performance.now() - startTime;
 // Cap progress at 99% until rendering is actually complete
 const percent = Math.min(99, Math.floor((elapsedTime / estimatedRenderTimeMs) * 100));
 btn.textContent = `Generating... ${percent}%`;
 // Use a slightly darker color for the progress fill to contrast
 btn.style.background = `linear-gradient(to right, var(--accent-secondary) ${percent}%, var(--accent) ${percent}%)`;
 }, 150);

 const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(2, sampleRate * durationSeconds, sampleRate);

 const nodes = this.buildOfflineEngine(offlineCtx);

 // Schedule singing bowl triggers for offline rendering
 if (nodes.bowl && this.state.isBowlEnabled) {
    for (let t = 0; t < durationSeconds; t += 60) {
        const time = t;
        const envelope = nodes.bowl.envelope;
        envelope.gain.cancelScheduledValues(time);
        envelope.gain.setValueAtTime(0, time);
        envelope.gain.linearRampToValueAtTime(1.0, time + 0.2);
        envelope.gain.exponentialRampToValueAtTime(this.config.MIN_GAIN, time + 45);
    }
 }

 const totalDur = durationSeconds;
 const stageDur = totalDur / this.state.STAGES.length;

 this.state.STAGES.forEach((stage, idx) => {
 const startTime = idx * stageDur;
 const rampTime = Math.min(this.config.STAGE_CHANGE_RAMP_S, stageDur * 0.5);

 nodes.carrier.setBinaural(stage.base, stage.beat, startTime, rampTime);
 nodes.pad.setFilter(stage.padCut, startTime, rampTime);
 if (nodes.iso) nodes.iso.setRate(stage.iso, startTime, rampTime);
 
 if (nodes.noise) {
     const noiseGain = stage.noise;
     if (startTime === 0) {
         nodes.noise.source.gain.setValueAtTime(noiseGain, 0);
     } else {
         nodes.noise.source.gain.linearRampToValueAtTime(noiseGain, startTime + rampTime);
     }
 }
 if (nodes.deepSleep) {
    const leftFreq = Math.max(8, stage.base - stage.beat / 2);
    const rightFreq = Math.max(8, stage.base + stage.beat / 2);

    if (startTime === 0) {
        nodes.deepSleep.leftOsc.frequency.setValueAtTime(leftFreq, 0);
        nodes.deepSleep.rightOsc.frequency.setValueAtTime(rightFreq, 0);
    } else {
        // Replaced setValueAtTime with linearRampToValueAtTime to prevent audible clicks.
        nodes.deepSleep.leftOsc.frequency.linearRampToValueAtTime(leftFreq, startTime + rampTime);
        nodes.deepSleep.rightOsc.frequency.linearRampToValueAtTime(rightFreq, startTime + rampTime);
    }
    
    const targetGain = (stage.deepSleepOn && this.state.isDeepSleepEnabled)
        ? this.config.DEEP_SLEEP_GAIN_MULTIPLIER
        : this.config.MIN_GAIN;
    
    if (startTime === 0) {
        nodes.deepSleep.gainNode.gain.setValueAtTime(targetGain, 0);
    } else {
        nodes.deepSleep.gainNode.gain.linearRampToValueAtTime(targetGain, startTime + rampTime);
    }
 }
 });

 const masterGainValue = this.config.MASTER_GAIN_MULTIPLIER;
 nodes.masterGain.gain.setValueAtTime(masterGainValue, 0);

 const renderedBuffer = await offlineCtx.startRendering();

 clearInterval(progressInterval);
 progressInterval = null;
 
 btn.textContent = 'Encoding WAV...';
 btn.style.background = `var(--accent-secondary)`;

 const wavBlob = this.bufferToWav(renderedBuffer);

 const url = URL.createObjectURL(wavBlob);
 const a = document.createElement('a');
 a.style.display = 'none';
 a.href = url;
 a.download = `binaural-soundscape-${this.ui.presetSelector.value}-${this.ui.lengthSlider.value}min.wav`;
 document.body.appendChild(a);
 a.click();
 window.URL.revokeObjectURL(url);
 a.remove();

 } catch (error) {
 console.error('Failed to save audio:', error);
 alert('An error occurred while saving the audio. Please check the console for details.');
 } finally {
 if (progressInterval) clearInterval(progressInterval);
 btn.disabled = false;
 btn.textContent = 'Save Audio';
 btn.style.background = null;
 }
 },

 buildOfflineEngine(ctx) {
 const masterGain = ctx.createGain();
 masterGain.connect(ctx.destination);

 const effectsGain = ctx.createGain();
 effectsGain.gain.value = parseFloat(this.ui.intensitySlider.value);
 effectsGain.connect(masterGain);
 
 const nodes = { masterGain, effectsGain };

 nodes.reverb = this.createReverb(ctx);
 nodes.reverb.connect(masterGain);
 
 nodes.carrier = this.createCarrierPair(ctx);
 nodes.carrier.outputLeft.connect(masterGain);
 nodes.carrier.outputRight.connect(masterGain);
 nodes.carrier.outputLeft.connect(nodes.reverb);
 nodes.carrier.outputRight.connect(nodes.reverb);
 
 nodes.pad = this.createPadLayer(ctx);
 nodes.pad.output.connect(masterGain);
 nodes.pad.output.connect(nodes.reverb);
 nodes.pad.output.gain.value = this.config.PAD_GAIN_MULTIPLIER;

 const creators = {
 iso: this.createIsoLayer, noise: this.createPinkNoise, wind: this.createWindSound,
 drum: this.createShamanicDrum, bowl: this.createSingingBowl, deepSleep: this.createDeepSleepBinaural
 };
 
 this.toggleConfigs.forEach(({ stateKey, nodeKey }) => {
 const node = creators[nodeKey].call(this, ctx);
 const gainSwitch = ctx.createGain();
 gainSwitch.gain.value = this.state[stateKey] ? 1 : 0;
 
 const output = node.output || node;
 output.connect(gainSwitch);
 gainSwitch.connect(nodes.effectsGain);
 if (nodeKey !== 'deepSleep') gainSwitch.connect(nodes.reverb);

 nodes[nodeKey] = { ...node, gainSwitch, source: output };
 });

 return nodes;
 },

 bufferToWav(buffer) {
 const numOfChan = buffer.numberOfChannels, length = buffer.length * numOfChan * 2 + 44;
 const bufferOut = new ArrayBuffer(length), view = new DataView(bufferOut);
 const channels = [];
 let i, sample, offset = 0, pos = 0;

 const writeString = (v, o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };

 // RIFF chunk descriptor
 writeString(view, pos, 'RIFF'); pos += 4;
 view.setUint32(pos, length - 8, true); pos += 4; // chunk size
 writeString(view, pos, 'WAVE'); pos += 4; // format

 // "fmt " sub-chunk
 writeString(view, pos, 'fmt '); pos += 4; // sub-chunk 1 ID
 view.setUint32(pos, 16, true); pos += 4; // sub-chunk 1 size
 view.setUint16(pos, 1, true); pos += 2; // audio format (1 = PCM)
 view.setUint16(pos, numOfChan, true); pos += 2; // number of channels
 view.setUint32(pos, buffer.sampleRate, true); pos += 4; // sample rate
 view.setUint32(pos, buffer.sampleRate * 2 * numOfChan, true); pos += 4; // byte rate (SampleRate * NumChannels * BitsPerSample/8)
 view.setUint16(pos, numOfChan * 2, true); pos += 2; // block align (NumChannels * BitsPerSample/8)
 view.setUint16(pos, 16, true); pos += 2; // bits per sample

 // "data" sub-chunk
 writeString(view, pos, 'data'); pos += 4; // sub-chunk 2 ID
 view.setUint32(pos, length - pos - 4, true); pos += 4; // sub-chunk 2 size (NumSamples * NumChannels * BitsPerSample/8)

 for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));

 while (pos < length) {
 for (i = 0; i < numOfChan; i++) {
 sample = Math.max(-1, Math.min(1, channels[i][offset]));
 sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
 view.setInt16(pos, sample, true);
 pos += 2;
 }
 offset++;
 }
 
 return new Blob([view], { type: 'audio/wav' });
 },
 };
 
 window.onload = () => app.init();
</script>
</body>
</html>
