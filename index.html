<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Vibrational Soundscape — Multi‑Stage</title>
<style>
  :root{--bg:#071428;--muted:#8fb8c6;--card:#e6f6f3}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Helvetica,Arial;color:var(--card);background:linear-gradient(180deg,#041122 0%,#071428 100%)}
  .app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
  .shell{width:min(1040px,96%);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:14px;padding:18px;display:grid;grid-template-columns:1fr 360px;gap:18px;box-shadow:0 12px 40px rgba(2,6,23,0.6)}
  @media(max-width:920px){.shell{grid-template-columns:1fr}}
  h1{margin:0;font-size:20px}
  .left{padding:12px}
  .visual{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.01));border-radius:10px;padding:12px;display:flex;flex-direction:column;align-items:center}
  #bgCanvas{width:100%;height:360px;border-radius:8px;display:block}
  .stageName{font-weight:700;margin-top:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .btn{background:#2e6f9e;border:0;color:white;padding:10px 12px;border-radius:10px;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.05)}
  label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
  input[type=range]{width:100% ; height:3rem;}
  .right{padding:12px;display:flex;flex-direction:column;gap:12px}
  .panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px}
  .dots{display:flex;gap:8px;justify-content:center;margin-top:8px}
  .dot{width:14px;height:14px;border-radius:50%;opacity:0.45;transform:scale(1);transition:all .28s}
  .dot.active{opacity:1;transform:scale(1.25)}
  .dot.g1{background:#ff7a59}
  .dot.g2{background:#ffd166}
  .dot.g3{background:#ffef9c}
  .dot.g4{background:#6ee7b7}
  .dot.g5{background:#8c6ff7}
  .muted{color:var(--muted);font-size:13px}
  canvas.wave{width:100%;height:84px;margin-top:12px;border-radius:8px;background:#031724}
</style>
</head>
<body>
  <div class="app">
    <div class="shell" role="application" aria-label="Vibrational Soundscape">
      <div class="left">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <h1>Vibrational Soundscape — Grounding → Bliss</h1>
            <div class="muted">Headphones recommended • Use low volume • Not for driving or machinery</div>
          </div>
          <div class="muted">v1.1</div>
        </div>

        <div class="visual">
          <canvas id="bgCanvas"></canvas>
          <div class="stageName" id="stageName">Idle • Ready</div>
          <div class="muted" id="stageSub">Manual step or Auto-play available</div>

          <canvas id="waveCanvas" class="wave" aria-hidden="true"></canvas>
          <div class="dots" aria-hidden="true">
            <div class="dot g1" id="dot0"></div>
            <div class="dot g2" id="dot1"></div>
            <div class="dot g3" id="dot2"></div>
            <div class="dot g4" id="dot3"></div>
            <div class="dot g5" id="dot4"></div>
          </div>
        </div>

        <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <button class="btn" id="startAuto">Start Auto</button>
          <button class="btn ghost" id="nextStage">Next Stage (manual)</button>
          <button class="btn ghost" id="pauseBtn" disabled>Pause/Resume</button>
          <button class="btn ghost" id="stopBtn" disabled>Stop</button>
        </div>

        <label>Session length (minutes): <span id="lenLabel">10</span>
          <input id="lengthSlider" type="range" min="3" max="60" value="10">
        </label>
        <label>Intensity: <span id="intLabel">0.6</span>
          <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.6">
        </label>
        <label><input id="isoChk" type="checkbox" checked> Isochronic gating</label>
        <label><input id="noiseChk" type="checkbox" checked> Pink noise</label>

      </div>

      <div class="right">
        <div class="panel">
          <strong>How progression works</strong>
          <p class="muted">You can step manually through the five stages or run an automated session. Each stage gently ramps carrier frequencies, pad filters, isochronic rate, noise level and ambience to minimize abrupt sensation. The automation schedules smooth linear ramps so transitions feel hypnotic and safe.</p>
        </div>

        <div class="panel">
          <strong>Stages</strong>
          <ol class="muted">
            <li><b>Grounding</b> — deep hum, slow breath</li>
            <li><b>Energetic</b> — nerve-tingle textures</li>
            <li><b>Mental</b> — clarity, midband polish</li>
            <li><b>Intuitive</b> — alpha/theta focus</li>
            <li><b>Bliss / Transcendent</b> — harmonic bloom</li>
          </ol>
        </div>

        <div class="panel muted">Safety: Start very low, stop immediately if you feel discomfort (dizziness, headache, ringing). Not medical advice.</div>
      </div>
    </div>
  </div>



<p>
Vibrational Soundscape is a web application that generates a relaxing and immersive audio experience through a series of "stages." This app is designed to help users transition through different mental states, from a calm, grounded state to a more blissful, transcendent one. It uses pure JavaScript and the Web Audio API, so it runs entirely in your browser without needing any external servers or plugins.

How It Works.
The app works by generating and blending different layers of sound, including:

Carrier Frequencies: Two sine wave oscillators with slightly different frequencies create a binaural beat effect, a type of auditory illusion that can influence brainwave activity. The app adjusts these frequencies to correspond with different mental states.

Pad Layer: A set of sine wave oscillators creates a soft, ambient "pad" of sound. A low-pass filter on this layer is adjusted to alter the texture of the sound as you progress through the stages.

Pink Noise: This type of noise, which sounds like a gentle hiss or rumble, is included to add warmth and a sense of natural ambience to the soundscape.

Isochronic Gating: A pulsing tone is used to create an isochronic beat. This is similar to a binaural beat but uses a single, pulsing tone that can be even more effective for some users in promoting relaxation and focus.

Reverb: A custom reverb effect is applied to all the sound layers, giving the entire soundscape a spacious, immersive quality.

Each of these sound layers is carefully balanced and modulated to create a smooth, evolving audio experience. The app also features a visualizer that reacts to the sound, showing a waveform and animated background rings.

Features.
Multi-Stage Progression: The app guides you through five distinct stages, each with its own unique sound profile and intended effect:

Grounding: A deep, slow hum for relaxation.

Energetic: Adds nerve-tingling textures.

Mental: Focuses on clarity.

Intuitive: Shifts to alpha/theta brainwave frequencies.

Bliss: A rich, harmonic soundscape.

Automated or Manual Control: You can either let the app run on a timer with an automated progression through the stages or manually advance through them at your own pace.

Customizable Session: Adjust the session length and overall intensity of the soundscape to suit your preference.

On-the-Fly Toggles: You have the option to enable or disable the isochronic gating and pink noise layers.

Safety and Use.
For the best experience, headphones are highly recommended. Use a low volume to avoid discomfort. As a safety precaution, the app includes a warning to start with very low intensity and stop immediately if you feel any discomfort. This app is not medical advice and is not intended to be used while driving or operating machinery.

For developers, the code is well-structured and uses pure JavaScript, making it an excellent example of using the Web Audio API to create a dynamic, interactive audio application. It's a great starting point for anyone interested in sound synthesis and audio processing in the browser.

    
  </p>

<script>
// Multi-stage soundscape engine (pure JS). This update reintroduces both manual step and auto progression.

const STAGES = [
  {name:'Grounding', base:55, beat:2.5, padCut:900, iso:2.0, noise:0.08},
  {name:'Energetic', base:95, beat:6.5, padCut:1200, iso:4.5, noise:0.095},
  {name:'Mental', base:140, beat:10.0, padCut:1800, iso:3.0, noise:0.06},
  {name:'Intuitive', base:160, beat:7.5, padCut:2500, iso:2.0, noise:0.045},
  {name:'Bliss', base:240, beat:40.0, padCut:4800, iso:0.8, noise:0.02}
];

let audioCtx=null, masterGain=null, analyser=null, nodes={}, running=false, rafId=null, currentStage=-1, autoTimer=null;

function createAudioContext(){ if(audioCtx) return audioCtx; audioCtx = new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }

function buildEngine(){
  const ctx = createAudioContext();
  masterGain = ctx.createGain(); masterGain.gain.value = 0.0001; masterGain.connect(ctx.destination);
  analyser = ctx.createAnalyser(); analyser.fftSize = 2048; masterGain.connect(analyser);

  nodes.reverb = createReverb(ctx,5,3.0);
  nodes.reverbGain = ctx.createGain(); nodes.reverbGain.gain.value = 0.45; nodes.reverb.connect(masterGain);

  // carrier pair (left/right)
  nodes.carrier = createCarrierPair(ctx);
  nodes.carrier.outputLeft.connect(masterGain);
  nodes.carrier.outputRight.connect(masterGain);
  // also send to reverb
  nodes.carrier.outputLeft.connect(nodes.reverb);
  nodes.carrier.outputRight.connect(nodes.reverb);

  // pad layer
  nodes.pad = createPadLayer(ctx);
  nodes.pad.output.connect(masterGain);
  nodes.pad.output.connect(nodes.reverb);

  // noise
  if (document.getElementById('noiseChk').checked) {
    nodes.noise = createPinkNoise(ctx);
    nodes.noise.gain.value = STAGES[0].noise * parseFloat(document.getElementById('intensity').value);
    nodes.noise.connect(masterGain);
    nodes.noise.connect(nodes.reverb);
  }

  // iso
  if (document.getElementById('isoChk').checked) {
    nodes.iso = createIsoLayer(ctx);
    nodes.iso.output.connect(masterGain);
    nodes.iso.output.connect(nodes.reverb);
  }

  return ctx;
}

function createCarrierPair(ctx){
  const left = ctx.createOscillator(); const right = ctx.createOscillator(); left.type='sine'; right.type='sine';
  left.frequency.value = 60; right.frequency.value = 60;
  const lfo = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.06; const lfoG = ctx.createGain(); lfoG.gain.value = 1.6; lfo.connect(lfoG); lfoG.connect(left.frequency); lfoG.connect(right.frequency); lfo.start();

  const panL = ctx.createStereoPanner(); panL.pan.value = -0.6; const panR = ctx.createStereoPanner(); panR.pan.value = 0.6;
  const gL = ctx.createGain(); const gR = ctx.createGain(); gL.gain.value = 0.45 * parseFloat(document.getElementById('intensity').value); gR.gain.value = 0.45 * parseFloat(document.getElementById('intensity').value);

  left.connect(panL); right.connect(panR); panL.connect(gL); panR.connect(gR);

  const outL = ctx.createGain(); const outR = ctx.createGain(); gL.connect(outL); gR.connect(outR);

  left.start(); right.start();

  return {
    leftOsc: left, rightOsc: right, outputLeft: outL, outputRight: outR,
    setBinaural: (base, beat, when=ctx.currentTime, ramp=4) => {
      const l = Math.max(8, base - beat/2); const r = Math.max(8, base + beat/2);
      try{ left.frequency.cancelScheduledValues(when-0.02); right.frequency.cancelScheduledValues(when-0.02); }catch(e){}
      left.frequency.linearRampToValueAtTime(l, when + ramp);
      right.frequency.linearRampToValueAtTime(r, when + ramp);
    }
  };
}

function createPadLayer(ctx){
  const master = ctx.createGain(); master.gain.value = 0.0;
  const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1200; filter.Q.value = 0.7;
  master.connect(filter);
  const out = ctx.createGain(); out.gain.value = 0.6 * parseFloat(document.getElementById('intensity').value);
  filter.connect(out);

  const base = 110; const oscs = [];
  for(let i=0;i<3;i++){
    const osc = ctx.createOscillator(); osc.type='sine'; osc.frequency.value = base * (1 + (i-1)*0.02);
    const lfo = ctx.createOscillator(); lfo.frequency.value = 0.02 + Math.random()*0.04; const lg = ctx.createGain(); lg.gain.value = 0.5 + Math.random()*0.6; lfo.connect(lg); lg.connect(osc.frequency); lfo.start(); osc.start(); osc.connect(master);
    oscs.push(osc);
  }
  // amplitude wobble
  const ampLFO = ctx.createOscillator(); ampLFO.frequency.value = 0.03; const ampG = ctx.createGain(); ampG.gain.value = 0.25; ampLFO.connect(ampG); ampG.connect(master.gain); ampLFO.start();

  return {output:out, oscs, setFilter: (cut, when=ctx.currentTime, ramp=4) => { try{ filter.frequency.cancelScheduledValues(when-0.02); }catch(e){} filter.frequency.linearRampToValueAtTime(cut, when + ramp); }};
}

function createPinkNoise(ctx){
  const buffer = ctx.createBuffer(1, ctx.sampleRate*3, ctx.sampleRate); const data = buffer.getChannelData(0);
  let b0=0,b1=0,b2=0,b3=0;
  for(let i=0;i<data.length;i++){ const white = Math.random()*2-1; b0=0.99765*b0+white*0.0990460; b1=0.96300*b1+white*0.2965164; b2=0.57000*b2+white*1.0526913; data[i]=b0+b1+b2+white*0.1848; data[i]*=0.11; }
  const src = ctx.createBufferSource(); src.buffer = buffer; src.loop = true; const g = ctx.createGain(); g.gain.value = 0.06 * parseFloat(document.getElementById('intensity').value); src.connect(g); src.start(); return g;
}

function createIsoLayer(ctx){
  const osc = ctx.createOscillator(); osc.type='sine'; osc.frequency.value = 80; const outG = ctx.createGain(); outG.gain.value = 0.45 * parseFloat(document.getElementById('intensity').value);
  const gate = ctx.createOscillator(); gate.type='sine'; gate.frequency.value = 4.0; const gateG = ctx.createGain(); gateG.gain.value = 0.6; gate.connect(gateG); gateG.connect(outG.gain);
  osc.connect(outG); osc.start(); gate.start(); return {output: outG, osc, gate, setRate:(hz,when=ctx.currentTime,ramp=2)=>{ try{ gate.frequency.cancelScheduledValues(when-0.02);}catch(e){} gate.frequency.linearRampToValueAtTime(hz, when + ramp); }};
}

function createReverb(ctx, duration=3, decay=3.0){
  const rate = ctx.sampleRate; const len = Math.floor(duration * rate); const buf = ctx.createBuffer(2, len, rate);
  for(let ch=0; ch<2; ch++){ const d = buf.getChannelData(ch); for(let i=0;i<len;i++){ const t = i / rate; d[i] = (Math.random()*2-1) * Math.pow(1 - t/duration, decay); }}
  const conv = ctx.createConvolver(); conv.buffer = buf; return conv;
}

// Schedule progression
function setStage(idx, when=audioCtx ? audioCtx.currentTime : 0, ramp=3){
  if (!audioCtx || !nodes.carrier || !nodes.pad) return;
  currentStage = idx;
  const s = STAGES[idx];
  nodes.carrier.setBinaural(s.base, s.beat, when, ramp);
  nodes.pad.setFilter(s.padCut, when, ramp);
  if (nodes.iso) nodes.iso.setRate(s.iso, when, ramp);
  if (nodes.noise) {
    try{ nodes.noise.gain.cancelScheduledValues(when-0.02); }catch(e){}
    nodes.noise.gain.linearRampToValueAtTime(s.noise * parseFloat(document.getElementById('intensity').value), when + ramp);
  }
  updateUIStage(idx);
}

function updateUIStage(idx){ const nameEl = document.getElementById('stageName'); const sub = document.getElementById('stageSub'); if (idx<0){ nameEl.textContent = 'Idle • Ready'; sub.textContent = 'Manual step or Auto-play available'; } else { nameEl.textContent = STAGES[idx].name; sub.textContent = 'Stage '+(idx+1)+' of '+STAGES.length; } for(let i=0;i<STAGES.length;i++){ const d = document.getElementById('dot'+i); if (d) d.classList.toggle('active', i===idx); } }

// Auto progression
function startAuto(){ if (running) return; const durationMin = parseInt(document.getElementById('lengthSlider').value,10); const totalSec = durationMin*60; startEngine(); const stageDur = totalSec / STAGES.length; let t0 = audioCtx.currentTime; STAGES.forEach((s, i)=>{ const startWhen = t0 + i*stageDur; setTimeout(()=>{ setStage(i, audioCtx.currentTime, Math.min(6, stageDur*0.6)); }, Math.max(0,(startWhen - audioCtx.currentTime)*1000)); }); // schedule stop
  setTimeout(()=>{ stopEngine(); }, (totalSec+1)*1000);
}

// Manual step
function nextStage(){ if (!running) { startEngine(); setTimeout(()=>{ nextStage(); }, 200); return; } const next = (currentStage + 1) % STAGES.length; setStage(next, audioCtx.currentTime, 2); }

// Engine lifecycle
function startEngine(){ if (running) return; const ctx = buildEngine(); ctx.resume(); masterGain.gain.cancelScheduledValues(0); masterGain.gain.setValueAtTime(0.0001, ctx.currentTime); masterGain.gain.exponentialRampToValueAtTime(0.45 * parseFloat(document.getElementById('intensity').value), ctx.currentTime + 6);
  running = true; document.getElementById('startAuto').disabled = true; document.getElementById('stopBtn').disabled = false; document.getElementById('pauseBtn').disabled = false; renderVisuals(); updateUIStage(-1);
}

function pauseResume(){ if (!audioCtx) return; if (audioCtx.state === 'running') { audioCtx.suspend(); document.getElementById('pauseBtn').textContent = 'Resume'; } else { audioCtx.resume(); document.getElementById('pauseBtn').textContent = 'Pause/Resume'; } }

function stopEngine(){ if (!running) return; try{ masterGain.gain.cancelScheduledValues(0); masterGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 3); }catch(e){}
  setTimeout(()=>{
    // stop oscillators and sources safely
    try{
      if (nodes.carrier){ nodes.carrier.leftOsc.stop(); nodes.carrier.rightOsc.stop(); }
      if (nodes.pad && nodes.pad.oscs) nodes.pad.oscs.forEach(o=>{ try{o.stop();}catch(e){} });
      if (nodes.iso){ try{ nodes.iso.osc.stop(); nodes.iso.gate.stop(); }catch(e){} }
      if (nodes.noise && nodes.noise.context){ try{ /* nothing */ }catch(e){} }
    }catch(e){}
    try{ if (audioCtx) { audioCtx.close(); audioCtx = null; } }catch(e){}
    nodes = {}; running = false; currentStage = -1;
    document.getElementById('startAuto').disabled = false; document.getElementById('stopBtn').disabled = true; document.getElementById('pauseBtn').disabled = true; updateUIStage(-1);
    if (rafId) cancelAnimationFrame(rafId);
  }, 3300);
}

// Visuals
const bgCanvas = document.getElementById('bgCanvas'); const bg = bgCanvas.getContext('2d'); const waveCanvas = document.getElementById('waveCanvas'); const wave = waveCanvas.getContext('2d');
function fitCanvases(){ bgCanvas.width = bgCanvas.clientWidth * devicePixelRatio; bgCanvas.height = bgCanvas.clientHeight * devicePixelRatio; waveCanvas.width = waveCanvas.clientWidth * devicePixelRatio; waveCanvas.height = waveCanvas.clientHeight * devicePixelRatio; }
window.addEventListener('resize', fitCanvases); fitCanvases();

function renderVisuals(){ if (!analyser) return; const buf = new Uint8Array(analyser.fftSize); const freq = new Uint8Array(analyser.frequencyBinCount);
  function draw(){ rafId = requestAnimationFrame(draw); analyser.getByteTimeDomainData(buf); analyser.getByteFrequencyData(freq);
    // background animated rings
    bg.clearRect(0,0,bgCanvas.width,bgCanvas.height);
    const t = performance.now()/1000;
    for(let r=0;r<4;r++){ bg.beginPath(); bg.strokeStyle = `rgba(120,200,220,${0.02 + r*0.01})`; bg.lineWidth = 1.2 * devicePixelRatio; const radius = (80 + r*40) * devicePixelRatio + Math.sin(t*0.6 + r) * 8; bg.arc(bgCanvas.width/2, bgCanvas.height/2, radius, 0, Math.PI*2); bg.stroke(); }
    // waveform
    wave.clearRect(0,0,waveCanvas.width,waveCanvas.height); wave.fillStyle = '#041a1f'; wave.fillRect(0,0,waveCanvas.width,waveCanvas.height);
    wave.lineWidth = 2 * devicePixelRatio; wave.strokeStyle = '#6de6c5'; wave.beginPath(); const slice = waveCanvas.width / buf.length; for(let i=0;i<buf.length;i++){ const v = buf[i] / 128.0; const y = v * (waveCanvas.height/2); const x = i * slice; if (i===0) wave.moveTo(x,y); else wave.lineTo(x,y); } wave.stroke();
  }
  draw();
}

// UI wiring
document.getElementById('startAuto').addEventListener('click', ()=>{ startAuto(); });
document.getElementById('nextStage').addEventListener('click', ()=>{ nextStage(); });
document.getElementById('pauseBtn').addEventListener('click', ()=>{ pauseResume(); });
document.getElementById('stopBtn').addEventListener('click', ()=>{ stopEngine(); });
document.getElementById('lengthSlider').addEventListener('input', e=>{ document.getElementById('lenLabel').textContent = e.target.value; });
document.getElementById('intensity').addEventListener('input', e=>{ document.getElementById('intLabel').textContent = e.target.value; });

// safe keyboard
window.addEventListener('keydown', e=>{ if (e.key===' ') { e.preventDefault(); document.getElementById('startAuto').click(); } if (e.key==='n') document.getElementById('nextStage').click(); });

// initial idle visuals
(function idleLoop(){ const c = bg; function loop(){ c.clearRect(0,0,bgCanvas.width,bgCanvas.height); const t = performance.now()/1000; for(let i=0;i<5;i++){ c.beginPath(); c.strokeStyle = `rgba(140,111,247,${0.02 + 0.01*Math.sin(t*0.6 + i)})`; c.lineWidth = 1.2 * devicePixelRatio; c.arc(bgCanvas.width/2, bgCanvas.height/2, (60 + i*28) * devicePixelRatio + Math.sin(t*0.6 + i)*6, 0, Math.PI*2); c.stroke(); } requestAnimationFrame(loop);} loop(); })();
</script>
</body>
</html>
