<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binaural Beats & Sound Therapy for Focus, Meditation & Sleep</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg: #1a120b;
      --bg-secondary: #2a1e14;
      --accent: #d4a017;
      --accent-secondary: #8b4513;
      --text: #f5f5f5;
      --muted: #a0a0a0;
      --checkmark-color: #4CAF50;
    }
    html, body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      height: 100%;
      background: var(--bg);
      color: var(--text);
    }
    
    /* Custom button icons */
    .play-icon {
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 17px solid white;
    }

    .pause-icon {
      width: 17px;
      height: 20px;
      border-left: 5px solid white;
      border-right: 5px solid white;
    }

    /* Custom slider styling for better cross-browser consistency */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      width: 100%;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      background: var(--bg-secondary);
      height: 8px;
      border-radius: 4px;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      height: 24px;
      width: 24px;
      background-color: var(--accent);
      border-radius: 50%;
      margin-top: -8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: all 0.2s ease-in-out;
    }
    input[type="range"]:active::-webkit-slider-thumb {
      transform: scale(1.1);
    }

    input[type="range"]::-moz-range-track {
      background: var(--bg-secondary);
      height: 8px;
      border-radius: 4px;
    }
    input[type="range"]::-moz-range-thumb {
      height: 24px;
      width: 24px;
      background-color: var(--accent);
      border-radius: 50%;
      border: none;
    }
    
    /* CSS Gradient Blob Animation */
    #gradientBlobsContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      filter: blur(80px); /* Gives the blobs a soft, shadowy look */
      opacity: 0.8;
    }
    .blob {
      position: absolute;
      background-image: radial-gradient(circle at center, rgba(212, 160, 23, 0.7), rgba(42, 30, 20, 0.2));
      border-radius: 50%;
      animation: float-blob 40s linear infinite alternate;
    }
    /* Individual blob sizes, positions, and animation delays */
    .blob:nth-child(1) {
      width: 250px;
      height: 250px;
      top: 10%;
      left: 20%;
      animation-delay: 2s;
    }
    .blob:nth-child(2) {
      width: 300px;
      height: 300px;
      top: 40%;
      left: 70%;
      animation-delay: 10s;
    }
    .blob:nth-child(3) {
      width: 200px;
      height: 200px;
      top: 60%;
      left: 15%;
      animation-delay: 20s;
    }
    .blob:nth-child(4) {
      width: 350px;
      height: 350px;
      top: 80%;
      left: 50%;
      animation-delay: 35s;
    }
    .blob:nth-child(5) {
      width: 180px;
      height: 180px;
      top: 5%;
      left: 80%;
      animation-delay: 15s;
    }

    @keyframes float-blob {
      0% {
        transform: translate(0, 0) scale(1.0);
      }
      25% {
        transform: translate(-10vw, -15vh) scale(1.1);
      }
      50% {
        transform: translate(15vw, 5vh) scale(0.9);
      }
      75% {
        transform: translate(-5vw, 10vh) scale(1.2);
      }
      100% {
        transform: translate(0, 0) scale(1.0);
      }
    }

    .checkmark.checked {
      background-color: var(--checkmark-color);
    }
  </style>
</head>
<body class="bg-[var(--bg)] text-[var(--text)] overflow-x-hidden min-h-screen flex flex-col items-center p-4 sm:p-6">
  
  <!-- CSS Gradient Blob Animation Container -->
  <div id="gradientBlobsContainer">
    <div class="blob"></div>
    <div class="blob"></div>
    <div class="blob"></div>
    <div class="blob"></div>
    <div class="blob"></div>
  </div>

  <div class="w-full max-w-2xl relative z-10 flex flex-col min-h-[calc(100vh-2rem)]">
    <!-- Header -->
    <div class="flex items-center justify-between py-4">
      <div class="text-left">
        <h1 class="text-3xl font-bold text-[var(--accent)]">Binaural Beats & Sound Therapy</h1>
        <p class="text-sm text-[var(--muted)]">Headphones recommended • Low volume</p>
      </div>
    </div>

    <!-- Main Visual Area (Simplified) -->
    <div class="bg-stone-800 bg-opacity-40 backdrop-blur-md rounded-2xl p-6 mb-8 flex flex-col items-center shadow-lg">
      <div id="stageInfo" class="w-full text-center">
        <div id="stageName" class="text-xl font-semibold text-[var(--accent)]">Idle • Ready</div>
        <div id="stageSub" class="text-sm text-[var(--muted)] mt-1">Manual step or Auto-play available</div>
        <div class="w-full h-1.5 bg-[var(--bg-secondary)] rounded-full mt-4 overflow-hidden">
          <div id="progressBar" class="h-full w-0 bg-[var(--accent)] transition-all duration-500 ease-in-out"></div>
        </div>
      </div>
    </div>

    <!-- Settings and Toggles -->
    <div class="bg-stone-800 bg-opacity-40 backdrop-blur-md rounded-2xl p-6 mb-8 shadow-lg">
      <h2 class="text-xl font-semibold mb-4">Presets</h2>
      
      <!-- Preset Dropdown -->
      <div class="mb-6">
        <label for="presetSelector" class="block text-sm font-medium text-[var(--text)] mb-2">Select a Preset</label>
        <select id="presetSelector" class="w-full p-2 rounded-lg bg-[var(--bg-secondary)] text-[var(--text)] border border-[var(--bg-secondary)] focus:outline-none focus:ring-2 focus:ring-[var(--accent)]">
          <option value="none">Custom</option>
          <option value="focus">Focus</option>
          <option value="meditation">Meditation</option>
          <option value="relaxation">Relaxation</option>
          <option value="deep_sleep">Deep Sleep</option>
          <option value="energetic">Energetic</option>
          <option value="bliss">Bliss</option>
        </select>
      </div>

      <h2 class="text-xl font-semibold mb-4">Settings</h2>
      
      <!-- Session Length Slider -->
      <div class="mb-6">
        <div class="flex justify-between items-center mb-2">
          <span class="text-sm text-[var(--text)]">Session length (minutes)</span>
          <span id="lenLabel" class="text-sm font-semibold text-[var(--accent)]">10</span>
        </div>
        <input id="lengthSlider" type="range" min="3" max="60" value="10">
      </div>

      <!-- Intensity Slider -->
      <div class="mb-6">
        <div class="flex justify-between items-center mb-2">
          <span class="text-sm text-[var(--text)]">Intensity</span>
          <span id="intLabel" class="text-sm font-semibold text-[var(--accent)]">0.6</span>
        </div>
        <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.6">
      </div>
      
      <!-- Checkmark Toggles -->
      <div class="space-y-4">
        <div id="isoOption" class="flex justify-between items-center cursor-pointer p-2 rounded-xl hover:bg-white/10 transition-colors">
          <span class="text-sm">Isochronic gating</span>
          <div class="w-6 h-6 rounded-full border-2 border-[var(--checkmark-color)] flex items-center justify-center transition-all duration-200" id="isoChkContainer">
            <div id="isoChk" class="w-4 h-4 rounded-full transition-all duration-200"></div>
          </div>
        </div>
        <div id="noiseOption" class="flex justify-between items-center cursor-pointer p-2 rounded-xl hover:bg-white/10 transition-colors">
          <span class="text-sm">Pink noise</span>
          <div class="w-6 h-6 rounded-full border-2 border-[var(--checkmark-color)] flex items-center justify-center transition-all duration-200" id="noiseChkContainer">
            <div id="noiseChk" class="w-4 h-4 rounded-full transition-all duration-200"></div>
          </div>
        </div>
        <div id="windOption" class="flex justify-between items-center cursor-pointer p-2 rounded-xl hover:bg-white/10 transition-colors">
          <span class="text-sm">3D Wind effect</span>
          <div class="w-6 h-6 rounded-full border-2 border-[var(--checkmark-color)] flex items-center justify-center transition-all duration-200" id="windChkContainer">
            <div id="windChk" class="w-4 h-4 rounded-full transition-all duration-200"></div>
          </div>
        </div>
        <div id="drumOption" class="flex justify-between items-center cursor-pointer p-2 rounded-xl hover:bg-white/10 transition-colors">
          <span class="text-sm">Shamanic drum</span>
          <div class="w-6 h-6 rounded-full border-2 border-[var(--checkmark-color)] flex items-center justify-center transition-all duration-200" id="drumChkContainer">
            <div id="drumChk" class="w-4 h-4 rounded-full transition-all duration-200"></div>
          </div>
        </div>
        <!-- New Toggle for Deep Sleep Waves -->
        <div id="deepSleepOption" class="flex justify-between items-center cursor-pointer p-2 rounded-xl hover:bg-white/10 transition-colors">
          <span class="text-sm">3D Sleep Waves</span>
          <div class="w-6 h-6 rounded-full border-2 border-[var(--checkmark-color)] flex items-center justify-center transition-all duration-200" id="deepSleepChkContainer">
            <div id="deepSleepChk" class="w-4 h-4 rounded-full transition-all duration-200"></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Info Cards -->
    <div class="info-cards space-y-4 mb-24">
      <div class="bg-stone-800 bg-opacity-40 backdrop-blur-md rounded-2xl p-6 shadow-lg">
        <h3 class="text-lg font-semibold text-[var(--accent)] mb-2">How to use</h3>
        <p class="text-sm leading-relaxed">Step through stages manually or use auto-play. Each stage gradually changes sound parameters for a smooth experience.</p>
      </div>
      <div class="bg-stone-800 bg-opacity-40 backdrop-blur-md rounded-2xl p-6 shadow-lg">
        <h3 class="text-lg font-semibold text-[var(--accent)] mb-2">Stages</h3>
        <ol class="list-decimal list-inside text-sm leading-relaxed space-y-1">
          <li><strong>Grounding</strong> — deep hum, slow breath</li>
          <li><strong>Energetic</strong> — nerve-tingle textures</li>
          <li><strong>Focus</strong> — clarity, midband polish</li>
          <li><strong>Intuitive</strong> — alpha/theta focus</li>
          <li><strong>Bliss</strong> — harmonic bloom</li>
        </ol>
      </div>
      <div class="bg-stone-800 bg-opacity-40 backdrop-blur-md rounded-2xl p-6 shadow-lg">
        <h3 class="text-lg font-semibold text-[var(--accent)] mb-2">Safety</h3>
        <p class="text-sm leading-relaxed">Start at low volume. Stop if you feel discomfort. Not for use while driving or operating machinery.</p>
      </div>
    </div>

    <!-- New Descriptive Text Section -->
    <div class="w-full relative z-10 flex flex-col">
        ---
        <div class="mt-8">
            <h2 class="text-2xl font-bold text-[var(--accent)] mb-4">About This Soundscape</h2>
            
            <h3 class="text-xl font-semibold text-[var(--text)] mb-2">What are Binaural Beats and Sound Therapy?</h3>
            <p class="text-sm leading-relaxed text-[var(--muted)] mb-4">
                This app is an immersive **binaural beat** soundscape designed to guide your mind into various states of consciousness. By playing two slightly different frequencies in each ear, it creates an auditory illusion that the brain perceives as a third tone—the **binaural beat**. This process, known as **brainwave entrainment**, can influence your mental state to help you relax, focus, or even fall asleep.
            </p>

            <h3 class="text-xl font-semibold text-[var(--text)] mb-2">The Stages of Sound and Their Effects</h3>
            <p class="text-sm leading-relaxed text-[var(--muted)] mb-4">
                Each stage of this soundscape is carefully engineered to produce a different mental effect, building on the previous one. The combination of subtle sound effects and binaural beats work together to gently shift your focus and awareness.
            </p>
            <ul class="list-none space-y-4 mb-4">
                <li>
                    <strong class="text-[var(--accent)]">Grounding:</strong> A deep, resonant hum combined with a slow beat helps quiet your mind and anchor your awareness in your body. It is ideal for starting a session of **mindfulness** or **meditation**.
                </li>
                <li>
                    <strong class="text-[var(--accent)]">Energetic:</strong> A slightly higher frequency hum and pulsing beat create a stimulating sensation, designed to promote a sense of vitality and awaken your nervous system.
                </li>
                <li>
                    <strong class="text-[var(--accent)]">Focus:</strong> The sound focuses on mid-range frequencies and beats that are associated with improved **concentration** and mental clarity, making it a great tool for **focus** during work or study.
                </li>
                <li>
                    <strong class="text-[var(--accent)]">Intuitive:</strong> The soundscape shifts to the alpha and theta brainwave range, which are linked to **deep relaxation**, **creativity** and accessing the subconscious mind. This is the stage for introspection and meditative states.
                </li>
                <li>
                    <strong class="text-[var(--accent)]">Bliss:</strong> A finale of complex, harmonic tones that create a full sound. This stage aims to evoke a sense of peacefulness, harmony, and overall **well-being**.
                </li>
            </ul>

            <h3 class="text-xl font-semibold text-[var(--text)] mb-2">Use Cases & Benefits</h3>
            <p class="text-sm leading-relaxed text-[var(--muted)] mb-4">
                This soundscape is a versatile tool for personal mental wellness. It can be used for:
            </p>
            <ul class="list-disc list-inside text-sm leading-relaxed text-[var(--muted)] mb-4 space-y-1">
                <li>**Meditation** and **mindfulness** practices</li>
                <li>**Relaxation** and **stress reduction**</li>
                <li>Enhancing **focus** and **concentration** during work or study sessions</li>
                <li>Boosting **creativity** and **intuition**</li>
                <li>Preparing for **sleep** or deep rest</li>
            </ul>
            <p class="text-sm leading-relaxed text-[var(--muted)]">
                The effectiveness of these sounds can vary by individual. Experiment with different session lengths and intensity levels to find what works best for you.
            </p>
        </div>
    </div>
  </div>
  
  <!-- Sticky Buttons -->
  <div class="fixed bottom-0 left-0 right-0 bg-[var(--bg)] bg-opacity-80 backdrop-blur-sm z-50 p-4 sm:p-6 shadow-2xl">
    <div class="flex gap-4 w-full max-w-2xl mx-auto">
      <button id="playPauseBtn" class="flex-1 flex items-center justify-center gap-2 bg-[var(--accent-secondary)] hover:bg-opacity-90 transition-colors text-white py-4 rounded-full font-semibold text-lg shadow-lg active:scale-95 transition-transform">
        <div class="play-icon" id="playIcon"></div>
        Play
      </button>
      <button id="nextStageBtn" class="flex-1 flex items-center justify-center gap-2 bg-transparent border-2 border-[var(--accent)] text-[var(--accent)] hover:bg-white/10 transition-colors py-4 rounded-full font-semibold text-lg shadow-lg active:scale-95 transition-transform">
        Next Stage
      </button>
    </div>
  </div>

<script>
  // Presets and STAGES
  const PRESETS = {
    none: {
      stages: [
        {name:'Grounding', base:55, beat:2.5, padCut:900, iso:2.0, noise:0.08},
        {name:'Energetic', base:95, beat:6.5, padCut:1200, iso:4.5, noise:0.095},
        {name:'Focus', base:140, beat:10.0, padCut:1800, iso:3.0, noise:0.06},
        {name:'Intuitive', base:160, beat:7.5, padCut:2500, iso:2.0, noise:0.045},
        {name:'Bliss', base:240, beat:40.0, padCut:4800, iso:0.8, noise:0.02}
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: true,
        drum: true,
        deepSleep: false,
      },
      intensity: 0.6
    },
    focus: {
      stages: [
        {name:'Beta Wave', base:140, beat:18.0, padCut:1500, iso:10.0, noise:0.05},
        {name:'Gamma Wave', base:200, beat:40.0, padCut:2500, iso:25.0, noise:0.0},
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: false,
        drum: false,
        deepSleep: false,
      },
      intensity: 0.8
    },
    meditation: {
      stages: [
        {name:'Alpha Wave', base:90, beat:10.0, padCut:800, iso:5.0, noise:0.04},
        {name:'Theta Wave', base:60, beat:6.0, padCut:500, iso:3.0, noise:0.02},
        {name:'Deep Theta', base:40, beat:4.0, padCut:300, iso:1.5, noise:0.01}
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: false,
        drum: true,
        deepSleep: false,
      },
      intensity: 0.5
    },
    relaxation: {
      stages: [
        {name:'Relax', base:120, beat:8.0, padCut:1000, iso:4.0, noise:0.03},
        {name:'Deep Calm', base:80, beat:6.0, padCut:700, iso:2.0, noise:0.01},
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: true,
        drum: false,
        deepSleep: false,
      },
      intensity: 0.4
    },
    deep_sleep: {
      stages: [
        {name:'Delta Wave', base:100, beat:2.0, padCut:250, iso:0.8, noise:0.05},
        {name:'Deep Delta', base:100, beat:0.5, padCut:150, iso:0.5, noise:0.08},
        // New stage for 3D sleep waves
        {name:'3D Delta', base:110, beat:1.5, padCut:100, iso:0.3, noise:0.0, deepSleepOn: true}
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: false,
        drum: false,
        deepSleep: true,
      },
      intensity: 0.3
    },
    energetic: {
      stages: [
        {name:'Energetic', base:95, beat:6.5, padCut:1200, iso:4.5, noise:0.095},
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: true,
        drum: true,
        deepSleep: false,
      },
      intensity: 0.6
    },
    bliss: {
      stages: [
        {name:'Bliss', base:240, beat:40.0, padCut:4800, iso:0.8, noise:0.02}
      ],
      toggles: {
        iso: true,
        noise: true,
        wind: true,
        drum: false,
        deepSleep: false,
      },
      intensity: 0.7
    }
  };

  let STAGES = PRESETS.none.stages;
  let audioCtx = null;
  let masterGain = null;
  let nodes = {};
  let currentStage = -1;
  let autoplayTimer = null;
  let isIsoEnabled = true;
  let isNoiseEnabled = true;
  let isWindEnabled = true;
  let isDrumEnabled = true;
  let isDeepSleepEnabled = false;

  // UI elements
  const playPauseBtn = document.getElementById('playPauseBtn');
  const playIcon = document.getElementById('playIcon');
  const nextStageBtn = document.getElementById('nextStageBtn');
  const lengthSlider = document.getElementById('lengthSlider');
  const intensitySlider = document.getElementById('intensity');
  const lenLabel = document.getElementById('lenLabel');
  const intLabel = document.getElementById('intLabel');
  const isoOption = document.getElementById('isoOption');
  const noiseOption = document.getElementById('noiseOption');
  const windOption = document.getElementById('windOption');
  const drumOption = document.getElementById('drumOption');
  const deepSleepOption = document.getElementById('deepSleepOption'); // New UI element
  const isoChk = document.getElementById('isoChk');
  const noiseChk = document.getElementById('noiseChk');
  const windChk = document.getElementById('windChk');
  const drumChk = document.getElementById('drumChk');
  const deepSleepChk = document.getElementById('deepSleepChk'); // New UI element
  const stageName = document.getElementById('stageName');
  const stageSub = document.getElementById('stageSub');
  const progressBar = document.getElementById('progressBar');
  const presetSelector = document.getElementById('presetSelector');
  
  // Audio functions
  const createAudioContext = () => {
    if (audioCtx) {
      audioCtx.close();
    }
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
  };

  const createReverb = (ctx, duration = 3, decay = 2.0) => {
    const rate = ctx.sampleRate;
    const len = Math.floor(duration * rate);
    const buf = ctx.createBuffer(2, len, rate);
    for(let ch = 0; ch < 2; ch++) {
      const d = buf.getChannelData(ch);
      for(let i = 0; i < len; i++) {
        const t = i / rate;
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - t/duration, decay);
      }
    }
    const conv = ctx.createConvolver();
    conv.buffer = buf;
    return conv;
  };
  
  const createCarrierPair = (ctx) => {
    const left = ctx.createOscillator();
    const right = ctx.createOscillator();
    left.type = 'sine';
    right.type = 'sine';
    left.frequency.value = 60;
    right.frequency.value = 60;
    left.start();
    right.start();
    
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.06;
    const lfoG = ctx.createGain();
    lfoG.gain.value = 1.6;
    lfo.connect(lfoG);
    lfoG.connect(left.frequency);
    lfoG.connect(right.frequency);
    lfo.start();

    const panL = ctx.createStereoPanner();
    panL.pan.value = -0.6;
    const panR = ctx.createStereoPanner();
    panR.pan.value = 0.6;

    const gL = ctx.createGain();
    const gR = ctx.createGain();
    gL.gain.value = 0.45;
    gR.gain.value = 0.45;

    left.connect(panL);
    right.connect(panR);
    panL.connect(gL);
    panR.connect(gR);

    return {
      leftOsc: left,
      rightOsc: right,
      outputLeft: gL,
      outputRight: gR,
      setBinaural: (base, beat, when = ctx.currentTime, ramp = 4) => {
        const l = Math.max(8, base - beat / 2);
        const r = Math.max(8, base + beat / 2);
        left.frequency.linearRampToValueAtTime(l, when + ramp);
        right.frequency.linearRampToValueAtTime(r, when + ramp);
      },
      gainNodeLeft: gL,
      gainNodeRight: gR
    };
  };

  const createPadLayer = (ctx) => {
    const master = ctx.createGain();
    master.gain.value = 0.0;
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1200;
    filter.Q.value = 0.7;
    master.connect(filter);

    const out = ctx.createGain();
    out.gain.value = 0.6;
    filter.connect(out);

    const base = 110;
    const oscs = [];
    for(let i = 0; i < 3; i++) {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = base * (1 + (i-1)*0.02);
      const lfo = ctx.createOscillator();
      lfo.frequency.value = 0.02 + Math.random()*0.04;
      const lg = ctx.createGain();
      lg.gain.value = 0.5 + Math.random()*0.6;
      lfo.connect(lg);
      lg.connect(osc.frequency);
      lfo.start();
      osc.start();
      osc.connect(master);
      oscs.push(osc);
    }

    const ampLFO = ctx.createOscillator();
    ampLFO.frequency.value = 0.03;
    const ampG = ctx.createGain();
    ampG.gain.value = 0.25;
    ampLFO.connect(ampG);
    ampG.connect(master.gain);
    ampLFO.start();

    return {
      output: out,
      oscs,
      filter,
      masterGain: master,
      ampLFO,
      ampGain: ampG,
      setFilter: (cut, when=ctx.currentTime, ramp=4) => {
        filter.frequency.linearRampToValueAtTime(cut, when + ramp);
      }
    };
  };

  const createPinkNoise = (ctx) => {
    const buffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    let b0 = 0, b1 = 0, b2 = 0;
    for(let i = 0; i < data.length; i++) {
      const white = Math.random() * 2 - 1;
      b0 = 0.99765 * b0 + white * 0.0990460;
      b1 = 0.96300 * b1 + white * 0.2965164;
      data[i] = b0 + b1 + white * 0.1848;
      data[i] *= 0.08;
    }
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    const g = ctx.createGain();
    src.connect(g);
    src.start();
    return g;
  };

  const createIsoLayer = (ctx) => {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 80;
    const outG = ctx.createGain();

    const gate = ctx.createOscillator();
    gate.type = 'sine';
    gate.frequency.value = 4.0;
    const gateG = ctx.createGain();
    gateG.gain.value = 0.6;
    gate.connect(gateG);
    gateG.connect(outG.gain);

    osc.connect(outG);
    osc.start();
    gate.start();

    return {
      output: outG,
      osc,
      gate,
      setRate: (hz, when=ctx.currentTime, ramp=2) => {
        gate.frequency.linearRampToValueAtTime(hz, when + ramp);
      },
      gainNode: outG
    };
  };

  const createWindSound = (ctx) => {
    // White noise source
    const bufferSize = ctx.sampleRate * 2;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const output = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      output[i] = Math.random() * 2 - 1;
    }
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;

    // Filter for a "wind" sound
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 400;
    filter.Q.value = 0.5;

    // LFO for subtle gain modulation (gusting effect)
    const gainLFO = ctx.createOscillator();
    gainLFO.type = 'sine';
    gainLFO.frequency.value = 0.08;
    const gainMod = ctx.createGain();
    gainMod.gain.value = 0.3;
    gainLFO.connect(gainMod);

    // Main gain for the wind sound
    const mainGain = ctx.createGain();
    mainGain.gain.value = 0.15; // Initial gain

    // Panner for spatial effect
    const panner = ctx.createStereoPanner();
    panner.pan.value = 0; // Initial position

    // LFO for panning (spatial movement)
    const panLFO = ctx.createOscillator();
    panLFO.type = 'sine';
    panLFO.frequency.value = 0.05; // Pan back and forth slowly
    const panMod = ctx.createGain();
    panMod.gain.value = 0.8;
    panLFO.connect(panMod);
    panMod.connect(panner.pan);

    // Connections
    source.connect(filter);
    filter.connect(mainGain);
    gainMod.connect(mainGain.gain);
    mainGain.connect(panner);
    
    // Start the sources
    source.start();
    gainLFO.start();
    panLFO.start();

    return {
        output: panner,
        gainNode: mainGain
    };
  };

  // NEW SHAMANIC DRUM LAYER
  const createShamanicDrum = (ctx) => {
    // A very low-frequency sine wave to act as the sub-bass pulse
    const subOsc = ctx.createOscillator();
    subOsc.type = 'sine';
    subOsc.frequency.value = 35; 
    subOsc.start();

    // A low-frequency LFO to create a slow tremolo effect
    const tremoloLFO = ctx.createOscillator();
    tremoloLFO.type = 'sine';
    tremoloLFO.frequency.value = 0.3; // Very slow pulse rate
    tremoloLFO.start();

    // A gain node to control the tremolo intensity
    const tremoloGain = ctx.createGain();
    tremoloGain.gain.value = 0.5;
    tremoloLFO.connect(tremoloGain.gain);

    // The main gain node for the drum sound
    const mainGain = ctx.createGain();
    mainGain.gain.value = 0.1;

    // Connections
    subOsc.connect(tremoloGain);
    tremoloGain.connect(mainGain);

    return {
      output: mainGain,
      gainNode: mainGain,
    };
  };

  // NEW: 3D Binaural Beat Effect
  const createDeepSleepBinaural = (ctx) => {
    const carrierBase = 110; // A stable, low hum
    const beatRate = 1.5;   // Delta wave frequency for deep sleep

    // Left and right oscillators
    const leftOsc = ctx.createOscillator();
    leftOsc.type = 'sine';
    leftOsc.frequency.value = carrierBase - beatRate / 2;
    leftOsc.start();

    const rightOsc = ctx.createOscillator();
    rightOsc.type = 'sine';
    rightOsc.frequency.value = carrierBase + beatRate / 2;
    rightOsc.start();

    // LFO for smooth, breathing-like volume modulation
    const volumeLFO = ctx.createOscillator();
    volumeLFO.type = 'sine';
    volumeLFO.frequency.value = 0.08;
    volumeLFO.start();

    // Main gain node, connected to the volume LFO
    const masterGain = ctx.createGain();
    masterGain.gain.value = 0.1;
    const volGainMod = ctx.createGain();
    volGainMod.gain.value = 0.5; // Controls the depth of the volume wobble
    volumeLFO.connect(volGainMod);
    volGainMod.connect(masterGain.gain);

    // Panners to create 3D spatial movement
    const leftPanner = ctx.createStereoPanner();
    const rightPanner = ctx.createStereoPanner();

    // LFO for spatial panning
    const panLFO = ctx.createOscillator();
    panLFO.type = 'sine';
    panLFO.frequency.value = 0.015; // Very slow pan rate
    panLFO.start();

    // Connect LFO to panners
    panLFO.connect(leftPanner.pan);
    panLFO.connect(rightPanner.pan);

    // Connections
    leftOsc.connect(leftPanner);
    rightOsc.connect(rightPanner);
    
    // Merge panned signals before master gain
    const merger = ctx.createChannelMerger(2);
    leftPanner.connect(merger, 0, 0);
    rightPanner.connect(merger, 0, 1);
    merger.connect(masterGain);

    return {
      output: masterGain,
      gainNode: masterGain,
      setBinaural: (base, beat) => {
        leftOsc.frequency.setValueAtTime(base - beat / 2, ctx.currentTime);
        rightOsc.frequency.setValueAtTime(base + beat / 2, ctx.currentTime);
      }
    };
  };

  const buildEngine = () => {
    const ctx = createAudioContext();
    
    // Create and connect main gain node
    masterGain = ctx.createGain();
    masterGain.gain.value = 0; // Start at zero
    masterGain.connect(ctx.destination);
    
    // Create and connect all sound layers
    nodes.reverb = createReverb(ctx, 3, 2.0);
    nodes.reverb.connect(masterGain);
    
    nodes.carrier = createCarrierPair(ctx);
    nodes.pad = createPadLayer(ctx);
    nodes.iso = createIsoLayer(ctx);
    nodes.noise = createPinkNoise(ctx);
    nodes.wind = createWindSound(ctx);
    nodes.drum = createShamanicDrum(ctx);
    nodes.deepSleep = createDeepSleepBinaural(ctx);

    updateConnections();
    
    // Initial stage setting
    setStage(0, ctx.currentTime, 0.1);
  };
  
  const updateConnections = () => {
    // Disconnect all nodes
    Object.values(nodes).forEach(node => {
        if (node.output) {
            node.output.disconnect();
        }
    });

    // Reconnect based on toggle state
    nodes.carrier.outputLeft.connect(masterGain);
    nodes.carrier.outputRight.connect(masterGain);
    nodes.carrier.outputLeft.connect(nodes.reverb);
    nodes.carrier.outputRight.connect(nodes.reverb);

    nodes.pad.output.connect(masterGain);
    nodes.pad.output.connect(nodes.reverb);
    
    if (isIsoEnabled) {
      nodes.iso.output.connect(masterGain);
      nodes.iso.output.connect(nodes.reverb);
    }
    
    if (isNoiseEnabled) {
      nodes.noise.connect(masterGain);
      nodes.noise.connect(nodes.reverb);
    }

    if (isWindEnabled) {
      nodes.wind.output.connect(masterGain);
      nodes.wind.output.connect(nodes.reverb);
    }
    
    if (isDrumEnabled) {
      nodes.drum.output.connect(masterGain);
      nodes.drum.output.connect(nodes.reverb);
    }

    // New Connection for Deep Sleep Waves
    if (isDeepSleepEnabled) {
      nodes.deepSleep.output.connect(masterGain);
    }
  };

  const setStage = (idx, when = audioCtx ? audioCtx.currentTime : 0, ramp = 3) => {
    if (!audioCtx || !nodes.carrier || !nodes.pad) return;
    currentStage = idx;
    const s = STAGES[idx];
    nodes.carrier.setBinaural(s.base, s.beat, when, ramp);
    nodes.pad.setFilter(s.padCut, when, ramp);
    if (nodes.iso && isIsoEnabled) nodes.iso.setRate(s.iso, when, ramp);
    if (nodes.noise && isNoiseEnabled) {
      nodes.noise.gain.linearRampToValueAtTime(s.noise * parseFloat(intensitySlider.value), when + ramp);
    }
    // New logic to control the deep sleep effect
    if (nodes.deepSleep && s.deepSleepOn) {
        nodes.deepSleep.setBinaural(s.base, s.beat);
        nodes.deepSleep.gainNode.gain.linearRampToValueAtTime(0.15 * parseFloat(intensitySlider.value), when + ramp);
    } else if (nodes.deepSleep) {
        nodes.deepSleep.gainNode.gain.linearRampToValueAtTime(0, when + ramp);
    }
    updateUIStage(idx);
  };

  const updateUIStage = (idx) => {
    if (idx < 0) {
      stageName.textContent = 'Idle • Ready';
      stageSub.textContent = 'Manual step or Auto-play available';
      progressBar.style.width = '0%';
    } else {
      stageName.textContent = STAGES[idx].name;
      stageSub.textContent = `Stage ${idx + 1} of ${STAGES.length}`;
      const progress = ((idx + 1) / STAGES.length) * 100;
      progressBar.style.width = `${progress}%`;
    }
  };

  const startAuto = () => {
    const durationMin = parseInt(lengthSlider.value, 10);
    const totalSec = durationMin * 60;
    
    const stageDur = totalSec / STAGES.length;
    let t0 = audioCtx.currentTime;

    STAGES.forEach((s, i) => {
      const startWhen = t0 + i * stageDur;
      setTimeout(() => {
        if(audioCtx && audioCtx.state === 'running') {
          setStage(i, audioCtx.currentTime, Math.min(6, stageDur * 0.6));
        }
      }, Math.max(0, (startWhen - audioCtx.currentTime) * 1000));
    });

    autoplayTimer = setTimeout(() => {
      stopEngine();
    }, (totalSec + 1) * 1000);
  };
  
  const _nextStage = () => {
    if (currentStage >= STAGES.length - 1) {
      stopEngine();
    } else {
      setStage(currentStage + 1, audioCtx.currentTime, 4);
    }
  };


  const stopEngine = () => {
    if (!audioCtx) return;
    clearTimeout(autoplayTimer);
    try {
      masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
      masterGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 3);
    } catch(e) {
      console.error("Error stopping gain ramp:", e);
    }

    setTimeout(() => {
      try {
        if (audioCtx) {
          audioCtx.suspend();
        }
      } catch(e) {
        console.error("Error stopping audio nodes:", e);
      }
      currentStage = -1;
      updatePlayPauseButton('play');
      updateUIStage(-1);
    }, 3000); // Wait for gain ramp to finish
  };

  const pauseEngine = () => {
    if (!audioCtx || audioCtx.state !== 'running') return;
    masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
    masterGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 1);
    setTimeout(() => { audioCtx.suspend(); }, 1000);
  };

  const resumeEngine = () => {
    if (!audioCtx || audioCtx.state !== 'suspended') return;
    audioCtx.resume();
    masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
    masterGain.gain.linearRampToValueAtTime(0.45 * parseFloat(intensitySlider.value), audioCtx.currentTime + 2);
  };
  
  // UI update functions
  const updatePlayPauseButton = (state) => {
    playIcon.className = ''; // Clear all classes
    if (state === 'play') {
      playIcon.className = 'play-icon';
      playPauseBtn.innerHTML = '<div class="play-icon"></div> Play';
    } else {
      playIcon.className = 'pause-icon';
      playPauseBtn.innerHTML = '<div class="pause-icon"></div> Pause';
    }
  };

  const toggleCheckmark = (checkmark, isEnabled) => {
    if (isEnabled) {
      checkmark.classList.add('bg-white');
      checkmark.classList.remove('bg-black');
    } else {
      checkmark.classList.add('bg-black');
      checkmark.classList.remove('bg-white');
    }
  };

  const initUIState = () => {
    toggleCheckmark(isoChk, isIsoEnabled);
    toggleCheckmark(noiseChk, isNoiseEnabled);
    toggleCheckmark(windChk, isWindEnabled);
    toggleCheckmark(drumChk, isDrumEnabled);
    toggleCheckmark(deepSleepChk, isDeepSleepEnabled);
  };

  const updatePresetUI = (preset) => {
    if (preset.toggles.iso !== undefined) {
      isIsoEnabled = preset.toggles.iso;
      toggleCheckmark(isoChk, isIsoEnabled);
    }
    if (preset.toggles.noise !== undefined) {
      isNoiseEnabled = preset.toggles.noise;
      toggleCheckmark(noiseChk, isNoiseEnabled);
    }
    if (preset.toggles.wind !== undefined) {
      isWindEnabled = preset.toggles.wind;
      toggleCheckmark(windChk, isWindEnabled);
    }
    if (preset.toggles.drum !== undefined) {
      isDrumEnabled = preset.toggles.drum;
      toggleCheckmark(drumChk, isDrumEnabled);
    }
    if (preset.toggles.deepSleep !== undefined) {
      isDeepSleepEnabled = preset.toggles.deepSleep;
      toggleCheckmark(deepSleepChk, isDeepSleepEnabled);
    }
    intensitySlider.value = preset.intensity;
    intLabel.textContent = preset.intensity;
  };
  
  // Event Listeners
  playPauseBtn.addEventListener('click', async () => {
    if (!audioCtx) {
      buildEngine();
      await audioCtx.resume();
      masterGain.gain.linearRampToValueAtTime(0.45 * parseFloat(intensitySlider.value), audioCtx.currentTime + 2);
      updatePlayPauseButton('pause');
      startAuto();
    } else if (audioCtx.state === 'running') {
      pauseEngine();
      updatePlayPauseButton('play');
    } else if (audioCtx.state === 'suspended') {
      resumeEngine();
      updatePlayPauseButton('pause');
      startAuto();
    }
  });

  nextStageBtn.addEventListener('click', () => {
    if (audioCtx && audioCtx.state === 'running') {
      _nextStage();
    }
  });

  lengthSlider.addEventListener('input', e => {
    lenLabel.textContent = e.target.value;
  });

  intensitySlider.addEventListener('input', e => {
    intLabel.textContent = e.target.value;
    if (audioCtx && masterGain) {
      try {
        const gainValue = 0.45 * parseFloat(e.target.value);
        masterGain.gain.linearRampToValueAtTime(gainValue, audioCtx.currentTime + 0.1);
        if (nodes.pad) {
            nodes.pad.output.gain.linearRampToValueAtTime(0.6 * parseFloat(e.target.value), audioCtx.currentTime + 0.1);
        }
      } catch (error) {
        console.error("Could not update gain:", error);
      }
    }
  });

  isoOption.addEventListener('click', () => {
    isIsoEnabled = !isIsoEnabled;
    toggleCheckmark(isoChk, isIsoEnabled);
    if (audioCtx) updateConnections();
  });

  noiseOption.addEventListener('click', () => {
    isNoiseEnabled = !isNoiseEnabled;
    toggleCheckmark(noiseChk, isNoiseEnabled);
    if (audioCtx) updateConnections();
  });
  
  windOption.addEventListener('click', () => {
    isWindEnabled = !isWindEnabled;
    toggleCheckmark(windChk, isWindEnabled);
    if (audioCtx) updateConnections();
  });

  drumOption.addEventListener('click', () => {
    isDrumEnabled = !isDrumEnabled;
    toggleCheckmark(drumChk, isDrumEnabled);
    if (audioCtx) updateConnections();
  });

  deepSleepOption.addEventListener('click', () => {
    isDeepSleepEnabled = !isDeepSleepEnabled;
    toggleCheckmark(deepSleepChk, isDeepSleepEnabled);
    if (audioCtx) updateConnections();
  });

  presetSelector.addEventListener('change', (e) => {
    const presetName = e.target.value;
    const preset = PRESETS[presetName];
    if (preset) {
      STAGES = preset.stages;
      updatePresetUI(preset);
      if (audioCtx) {
        stopEngine();
        setTimeout(() => {
          buildEngine();
          audioCtx.resume();
          masterGain.gain.linearRampToValueAtTime(0.45 * parseFloat(intensitySlider.value), audioCtx.currentTime + 2);
          updatePlayPauseButton('pause');
          startAuto();
        }, 3100); // Give enough time for the engine to fully stop
      }
      updateUIStage(-1); // Reset UI to idle state
    }
  });
  
  window.onload = initUIState;

</script>

</body>
</html>
